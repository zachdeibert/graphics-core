// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

#pragma warning disable 618

namespace Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop
{
    /// <summary>Client API function pointer type.</summary>
    /// <remarks>
    /// <para>Generic function pointer used for returning client API function pointers</para>
    /// <para>without forcing a cast from a regular pointer.</para>
    /// <para>glfwGetProcAddress</para>
    /// <para>Added in version 3.0.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWglproc();

    /// <summary>Vulkan API function pointer type.</summary>
    /// <remarks>
    /// <para>Generic function pointer used for returning Vulkan API function pointers</para>
    /// <para>without forcing a cast from a regular pointer.</para>
    /// <para>glfwGetInstanceProcAddress</para>
    /// <para>Added in version 3.2.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWvkproc();

    /// <summary>Opaque monitor object.</summary>
    /// <remarks>
    /// <para>Opaque monitor object.</para>
    /// <para>Added in version 3.0.</para>
    /// </remarks>
    /// <summary>Opaque window object.</summary>
    /// <remarks>
    /// <para>Opaque window object.</para>
    /// <para>Added in version 3.0.</para>
    /// </remarks>
    /// <summary>Opaque cursor object.</summary>
    /// <remarks>
    /// <para>Opaque cursor object.</para>
    /// <para>Added in version 3.1.</para>
    /// </remarks>
    /// <summary>The function signature for error callbacks.</summary>
    /// <param name="error">An [error code](</param>
    /// <param name="description">A UTF-8 encoded string describing the error.</param>
    /// <remarks>
    /// <para>This is the function signature for error callback functions.</para>
    /// <para>glfwSetErrorCallback</para>
    /// <para>Added in version 3.0.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWerrorfun(int _0, [MarshalAs(UnmanagedType.LPStr)] string _1);

    /// <summary>The function signature for window position callbacks.</summary>
    /// <param name="window">The window that was moved.</param>
    /// <param name="xpos">
    /// <para>The new x-coordinate, in screen coordinates, of the</para>
    /// <para>upper-left corner of the client area of the window.</para>
    /// </param>
    /// <param name="ypos">
    /// <para>The new y-coordinate, in screen coordinates, of the</para>
    /// <para>upper-left corner of the client area of the window.</para>
    /// </param>
    /// <remarks>
    /// <para>This is the function signature for window position callback functions.</para>
    /// <para>glfwSetWindowPosCallback</para>
    /// <para>Added in version 3.0.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWwindowposfun(global::System.IntPtr _0, int _1, int _2);

    /// <summary>The function signature for window resize callbacks.</summary>
    /// <param name="window">The window that was resized.</param>
    /// <param name="width">The new width, in screen coordinates, of the window.</param>
    /// <param name="height">The new height, in screen coordinates, of the window.</param>
    /// <remarks>
    /// <para>This is the function signature for window size callback functions.</para>
    /// <para>glfwSetWindowSizeCallback</para>
    /// <para>Added in version 1.0.</para>
    /// <para>Added window handle parameter.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWwindowsizefun(global::System.IntPtr _0, int _1, int _2);

    /// <summary>The function signature for window close callbacks.</summary>
    /// <param name="window">The window that the user attempted to close.</param>
    /// <remarks>
    /// <para>This is the function signature for window close callback functions.</para>
    /// <para>glfwSetWindowCloseCallback</para>
    /// <para>Added in version 2.5.</para>
    /// <para>Added window handle parameter.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWwindowclosefun(global::System.IntPtr _0);

    /// <summary>The function signature for window content refresh callbacks.</summary>
    /// <param name="window">The window whose content needs to be refreshed.</param>
    /// <remarks>
    /// <para>This is the function signature for window refresh callback functions.</para>
    /// <para>glfwSetWindowRefreshCallback</para>
    /// <para>Added in version 2.5.</para>
    /// <para>Added window handle parameter.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWwindowrefreshfun(global::System.IntPtr _0);

    /// <summary>The function signature for window focus/defocus callbacks.</summary>
    /// <param name="window">The window that gained or lost input focus.</param>
    /// <param name="focused">
    /// <para>`GLFW_TRUE` if the window was given input focus, or</para>
    /// <para>`GLFW_FALSE` if it lost it.</para>
    /// </param>
    /// <remarks>
    /// <para>This is the function signature for window focus callback functions.</para>
    /// <para>glfwSetWindowFocusCallback</para>
    /// <para>Added in version 3.0.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWwindowfocusfun(global::System.IntPtr _0, int _1);

    /// <summary>The function signature for window iconify/restore callbacks.</summary>
    /// <param name="window">The window that was iconified or restored.</param>
    /// <param name="iconified">
    /// <para>`GLFW_TRUE` if the window was iconified, or</para>
    /// <para>`GLFW_FALSE` if it was restored.</para>
    /// </param>
    /// <remarks>
    /// <para>This is the function signature for window iconify/restore callback</para>
    /// <para>functions.</para>
    /// <para>glfwSetWindowIconifyCallback</para>
    /// <para>Added in version 3.0.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWwindowiconifyfun(global::System.IntPtr _0, int _1);

    /// <summary>The function signature for framebuffer resize callbacks.</summary>
    /// <param name="window">The window whose framebuffer was resized.</param>
    /// <param name="width">The new width, in pixels, of the framebuffer.</param>
    /// <param name="height">The new height, in pixels, of the framebuffer.</param>
    /// <remarks>
    /// <para>This is the function signature for framebuffer resize callback</para>
    /// <para>functions.</para>
    /// <para>glfwSetFramebufferSizeCallback</para>
    /// <para>Added in version 3.0.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWframebuffersizefun(global::System.IntPtr _0, int _1, int _2);

    /// <summary>The function signature for mouse button callbacks.</summary>
    /// <param name="window">The window that received the event.</param>
    /// <param name="button">The [mouse button](</param>
    /// <param name="action">One of `GLFW_PRESS` or `GLFW_RELEASE`.</param>
    /// <param name="mods">Bit field describing which [modifier keys](</param>
    /// <remarks>
    /// <para>This is the function signature for mouse button callback functions.</para>
    /// <para>released.</para>
    /// <para>held down.</para>
    /// <para>glfwSetMouseButtonCallback</para>
    /// <para>Added in version 1.0.</para>
    /// <para>Added window handle and modifier mask parameters.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWmousebuttonfun(global::System.IntPtr _0, int _1, int _2, int _3);

    /// <summary>The function signature for cursor position callbacks.</summary>
    /// <param name="window">The window that received the event.</param>
    /// <param name="xpos">
    /// <para>The new cursor x-coordinate, relative to the left edge of</para>
    /// <para>the client area.</para>
    /// </param>
    /// <param name="ypos">
    /// <para>The new cursor y-coordinate, relative to the top edge of the</para>
    /// <para>client area.</para>
    /// </param>
    /// <remarks>
    /// <para>This is the function signature for cursor position callback functions.</para>
    /// <para>glfwSetCursorPosCallback</para>
    /// <para>Added in version 3.0.  Replaces `GLFWmouseposfun`.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWcursorposfun(global::System.IntPtr _0, double _1, double _2);

    /// <summary>The function signature for cursor enter/leave callbacks.</summary>
    /// <param name="window">The window that received the event.</param>
    /// <param name="entered">
    /// <para>`GLFW_TRUE` if the cursor entered the window's client</para>
    /// <para>area, or `GLFW_FALSE` if it left it.</para>
    /// </param>
    /// <remarks>
    /// <para>This is the function signature for cursor enter/leave callback functions.</para>
    /// <para>glfwSetCursorEnterCallback</para>
    /// <para>Added in version 3.0.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWcursorenterfun(global::System.IntPtr _0, int _1);

    /// <summary>The function signature for scroll callbacks.</summary>
    /// <param name="window">The window that received the event.</param>
    /// <param name="xoffset">The scroll offset along the x-axis.</param>
    /// <param name="yoffset">The scroll offset along the y-axis.</param>
    /// <remarks>
    /// <para>This is the function signature for scroll callback functions.</para>
    /// <para>glfwSetScrollCallback</para>
    /// <para>Added in version 3.0.  Replaces `GLFWmousewheelfun`.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWscrollfun(global::System.IntPtr _0, double _1, double _2);

    /// <summary>The function signature for keyboard key callbacks.</summary>
    /// <param name="window">The window that received the event.</param>
    /// <param name="key">The [keyboard key](</param>
    /// <param name="scancode">The system-specific scancode of the key.</param>
    /// <param name="action">`GLFW_PRESS`, `GLFW_RELEASE` or `GLFW_REPEAT`.</param>
    /// <param name="mods">Bit field describing which [modifier keys](</param>
    /// <remarks>
    /// <para>This is the function signature for keyboard key callback functions.</para>
    /// <para>held down.</para>
    /// <para>glfwSetKeyCallback</para>
    /// <para>Added in version 1.0.</para>
    /// <para>Added window handle, scancode and modifier mask parameters.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWkeyfun(global::System.IntPtr _0, int _1, int _2, int _3, int _4);

    /// <summary>The function signature for Unicode character callbacks.</summary>
    /// <param name="window">The window that received the event.</param>
    /// <param name="codepoint">The Unicode code point of the character.</param>
    /// <remarks>
    /// <para>This is the function signature for Unicode character callback functions.</para>
    /// <para>glfwSetCharCallback</para>
    /// <para>Added in version 2.4.</para>
    /// <para>Added window handle parameter.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWcharfun(global::System.IntPtr _0, uint _1);

    /// <summary>
    /// <para>The function signature for Unicode character with modifiers</para>
    /// <para>callbacks.</para>
    /// </summary>
    /// <param name="window">The window that received the event.</param>
    /// <param name="codepoint">The Unicode code point of the character.</param>
    /// <param name="mods">Bit field describing which [modifier keys](</param>
    /// <remarks>
    /// <para>This is the function signature for Unicode character with modifiers callback</para>
    /// <para>functions.  It is called for each input character, regardless of what</para>
    /// <para>modifier keys are held down.</para>
    /// <para>held down.</para>
    /// <para>glfwSetCharModsCallback</para>
    /// <para>Added in version 3.1.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWcharmodsfun(global::System.IntPtr _0, uint _1, int _2);

    /// <summary>The function signature for file drop callbacks.</summary>
    /// <param name="window">The window that received the event.</param>
    /// <param name="count">The number of dropped files.</param>
    /// <param name="paths">The UTF-8 encoded file and/or directory path names.</param>
    /// <remarks>
    /// <para>This is the function signature for file drop callbacks.</para>
    /// <para>glfwSetDropCallback</para>
    /// <para>Added in version 3.1.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWdropfun(global::System.IntPtr _0, int _1, sbyte** _2);

    /// <summary>The function signature for monitor configuration callbacks.</summary>
    /// <param name="monitor">The monitor that was connected or disconnected.</param>
    /// <param name="event">One of `GLFW_CONNECTED` or `GLFW_DISCONNECTED`.</param>
    /// <remarks>
    /// <para>This is the function signature for monitor configuration callback functions.</para>
    /// <para>glfwSetMonitorCallback</para>
    /// <para>Added in version 3.0.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWmonitorfun(global::System.IntPtr _0, int _1);

    /// <summary>The function signature for joystick configuration callbacks.</summary>
    /// <param name="joy">The joystick that was connected or disconnected.</param>
    /// <param name="event">One of `GLFW_CONNECTED` or `GLFW_DISCONNECTED`.</param>
    /// <remarks>
    /// <para>This is the function signature for joystick configuration callback</para>
    /// <para>functions.</para>
    /// <para>glfwSetJoystickCallback</para>
    /// <para>Added in version 3.2.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void GLFWjoystickfun(int _0, int _1);

    public unsafe partial class GLFWmonitor
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWmonitor> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWmonitor>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWmonitor __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWmonitor(native.ToPointer(), skipVTables);
        }

        internal static global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWmonitor __CreateInstance(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWmonitor.__Internal native, bool skipVTables = false)
        {
            return new global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWmonitor(native, skipVTables);
        }

        private static void* __CopyValue(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWmonitor.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWmonitor.__Internal));
            *(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWmonitor.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private GLFWmonitor(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWmonitor.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected GLFWmonitor(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class GLFWwindow
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow(native.ToPointer(), skipVTables);
        }

        internal static global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow __CreateInstance(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow.__Internal native, bool skipVTables = false)
        {
            return new global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow(native, skipVTables);
        }

        private static void* __CopyValue(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow.__Internal));
            *(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private GLFWwindow(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected GLFWwindow(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class GLFWcursor
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWcursor> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWcursor>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWcursor __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWcursor(native.ToPointer(), skipVTables);
        }

        internal static global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWcursor __CreateInstance(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWcursor.__Internal native, bool skipVTables = false)
        {
            return new global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWcursor(native, skipVTables);
        }

        private static void* __CopyValue(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWcursor.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWcursor.__Internal));
            *(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWcursor.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private GLFWcursor(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWcursor.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected GLFWcursor(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    /// <summary>Video mode type.</summary>
    /// <remarks>
    /// <para>This describes a single video mode.</para>
    /// <para>glfwGetVideoMode glfwGetVideoModes</para>
    /// <para>Added in version 1.0.</para>
    /// <para>Added refresh rate member.</para>
    /// </remarks>
    public unsafe partial class GLFWvidmode : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int width;

            [FieldOffset(4)]
            internal int height;

            [FieldOffset(8)]
            internal int redBits;

            [FieldOffset(12)]
            internal int greenBits;

            [FieldOffset(16)]
            internal int blueBits;

            [FieldOffset(20)]
            internal int refreshRate;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0GLFWvidmode@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWvidmode> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWvidmode>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWvidmode __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWvidmode(native.ToPointer(), skipVTables);
        }

        internal static global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWvidmode __CreateInstance(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWvidmode.__Internal native, bool skipVTables = false)
        {
            return new global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWvidmode(native, skipVTables);
        }

        private static void* __CopyValue(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWvidmode.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWvidmode.__Internal));
            *(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWvidmode.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private GLFWvidmode(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWvidmode.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected GLFWvidmode(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public GLFWvidmode()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWvidmode.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public GLFWvidmode(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWvidmode _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWvidmode.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWvidmode.__Internal*) __Instance) = *((global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWvidmode.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWvidmode __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Width
        {
            get
            {
                return ((global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWvidmode.__Internal*) __Instance)->width;
            }

            set
            {
                ((global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWvidmode.__Internal*) __Instance)->width = value;
            }
        }

        public int Height
        {
            get
            {
                return ((global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWvidmode.__Internal*) __Instance)->height;
            }

            set
            {
                ((global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWvidmode.__Internal*) __Instance)->height = value;
            }
        }

        public int RedBits
        {
            get
            {
                return ((global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWvidmode.__Internal*) __Instance)->redBits;
            }

            set
            {
                ((global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWvidmode.__Internal*) __Instance)->redBits = value;
            }
        }

        public int GreenBits
        {
            get
            {
                return ((global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWvidmode.__Internal*) __Instance)->greenBits;
            }

            set
            {
                ((global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWvidmode.__Internal*) __Instance)->greenBits = value;
            }
        }

        public int BlueBits
        {
            get
            {
                return ((global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWvidmode.__Internal*) __Instance)->blueBits;
            }

            set
            {
                ((global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWvidmode.__Internal*) __Instance)->blueBits = value;
            }
        }

        public int RefreshRate
        {
            get
            {
                return ((global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWvidmode.__Internal*) __Instance)->refreshRate;
            }

            set
            {
                ((global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWvidmode.__Internal*) __Instance)->refreshRate = value;
            }
        }
    }

    /// <summary>Gamma ramp.</summary>
    /// <remarks>
    /// <para>This describes the gamma ramp for a monitor.</para>
    /// <para>glfwGetGammaRamp glfwSetGammaRamp</para>
    /// <para>Added in version 3.0.</para>
    /// </remarks>
    public unsafe partial class GLFWgammaramp : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr red;

            [FieldOffset(8)]
            internal global::System.IntPtr green;

            [FieldOffset(16)]
            internal global::System.IntPtr blue;

            [FieldOffset(24)]
            internal uint size;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0GLFWgammaramp@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWgammaramp> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWgammaramp>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWgammaramp __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWgammaramp(native.ToPointer(), skipVTables);
        }

        internal static global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWgammaramp __CreateInstance(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWgammaramp.__Internal native, bool skipVTables = false)
        {
            return new global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWgammaramp(native, skipVTables);
        }

        private static void* __CopyValue(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWgammaramp.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWgammaramp.__Internal));
            *(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWgammaramp.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private GLFWgammaramp(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWgammaramp.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected GLFWgammaramp(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public GLFWgammaramp()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWgammaramp.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public GLFWgammaramp(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWgammaramp _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWgammaramp.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWgammaramp.__Internal*) __Instance) = *((global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWgammaramp.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWgammaramp __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ushort* Red
        {
            get
            {
                return (ushort*) ((global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWgammaramp.__Internal*) __Instance)->red;
            }

            set
            {
                ((global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWgammaramp.__Internal*) __Instance)->red = (global::System.IntPtr) value;
            }
        }

        public ushort* Green
        {
            get
            {
                return (ushort*) ((global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWgammaramp.__Internal*) __Instance)->green;
            }

            set
            {
                ((global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWgammaramp.__Internal*) __Instance)->green = (global::System.IntPtr) value;
            }
        }

        public ushort* Blue
        {
            get
            {
                return (ushort*) ((global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWgammaramp.__Internal*) __Instance)->blue;
            }

            set
            {
                ((global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWgammaramp.__Internal*) __Instance)->blue = (global::System.IntPtr) value;
            }
        }

        public uint Size
        {
            get
            {
                return ((global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWgammaramp.__Internal*) __Instance)->size;
            }

            set
            {
                ((global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWgammaramp.__Internal*) __Instance)->size = value;
            }
        }
    }

    /// <summary>Image data.</summary>
    /// <remarks>
    /// <para>Added in version 2.1.</para>
    /// <para>Removed format and bytes-per-pixel members.</para>
    /// </remarks>
    public unsafe partial class GLFWimage : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int width;

            [FieldOffset(4)]
            internal int height;

            [FieldOffset(8)]
            internal global::System.IntPtr pixels;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0GLFWimage@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWimage> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWimage>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWimage __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWimage(native.ToPointer(), skipVTables);
        }

        internal static global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWimage __CreateInstance(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWimage.__Internal native, bool skipVTables = false)
        {
            return new global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWimage(native, skipVTables);
        }

        private static void* __CopyValue(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWimage.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWimage.__Internal));
            *(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWimage.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private GLFWimage(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWimage.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected GLFWimage(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public GLFWimage()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWimage.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public GLFWimage(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWimage _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWimage.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWimage.__Internal*) __Instance) = *((global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWimage.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWimage __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Width
        {
            get
            {
                return ((global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWimage.__Internal*) __Instance)->width;
            }

            set
            {
                ((global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWimage.__Internal*) __Instance)->width = value;
            }
        }

        public int Height
        {
            get
            {
                return ((global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWimage.__Internal*) __Instance)->height;
            }

            set
            {
                ((global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWimage.__Internal*) __Instance)->height = value;
            }
        }

        public byte* Pixels
        {
            get
            {
                return (byte*) ((global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWimage.__Internal*) __Instance)->pixels;
            }

            set
            {
                ((global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWimage.__Internal*) __Instance)->pixels = (global::System.IntPtr) value;
            }
        }
    }

    public unsafe partial class GLFW
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwInit")]
            internal static extern int GlfwInit();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwTerminate")]
            internal static extern void GlfwTerminate();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetVersion")]
            internal static extern void GlfwGetVersion(int* major, int* minor, int* rev);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetVersionString")]
            internal static extern global::System.IntPtr GlfwGetVersionString();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetErrorCallback")]
            internal static extern global::System.IntPtr GlfwSetErrorCallback(global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetMonitors")]
            internal static extern global::System.IntPtr GlfwGetMonitors(int* count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetPrimaryMonitor")]
            internal static extern global::System.IntPtr GlfwGetPrimaryMonitor();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetMonitorPos")]
            internal static extern void GlfwGetMonitorPos(global::System.IntPtr monitor, int* xpos, int* ypos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetMonitorPhysicalSize")]
            internal static extern void GlfwGetMonitorPhysicalSize(global::System.IntPtr monitor, int* widthMM, int* heightMM);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetMonitorName")]
            internal static extern global::System.IntPtr GlfwGetMonitorName(global::System.IntPtr monitor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetMonitorCallback")]
            internal static extern global::System.IntPtr GlfwSetMonitorCallback(global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetVideoModes")]
            internal static extern global::System.IntPtr GlfwGetVideoModes(global::System.IntPtr monitor, int* count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetVideoMode")]
            internal static extern global::System.IntPtr GlfwGetVideoMode(global::System.IntPtr monitor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetGamma")]
            internal static extern void GlfwSetGamma(global::System.IntPtr monitor, float gamma);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetGammaRamp")]
            internal static extern global::System.IntPtr GlfwGetGammaRamp(global::System.IntPtr monitor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetGammaRamp")]
            internal static extern void GlfwSetGammaRamp(global::System.IntPtr monitor, global::System.IntPtr ramp);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwDefaultWindowHints")]
            internal static extern void GlfwDefaultWindowHints();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwWindowHint")]
            internal static extern void GlfwWindowHint(int hint, int value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwCreateWindow")]
            internal static extern global::System.IntPtr GlfwCreateWindow(int width, int height, [MarshalAs(UnmanagedType.LPStr)] string title, global::System.IntPtr monitor, global::System.IntPtr share);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwDestroyWindow")]
            internal static extern void GlfwDestroyWindow(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwWindowShouldClose")]
            internal static extern int GlfwWindowShouldClose(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetWindowShouldClose")]
            internal static extern void GlfwSetWindowShouldClose(global::System.IntPtr window, int value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetWindowTitle")]
            internal static extern void GlfwSetWindowTitle(global::System.IntPtr window, [MarshalAs(UnmanagedType.LPStr)] string title);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetWindowIcon")]
            internal static extern void GlfwSetWindowIcon(global::System.IntPtr window, int count, global::System.IntPtr images);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetWindowPos")]
            internal static extern void GlfwGetWindowPos(global::System.IntPtr window, int* xpos, int* ypos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetWindowPos")]
            internal static extern void GlfwSetWindowPos(global::System.IntPtr window, int xpos, int ypos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetWindowSize")]
            internal static extern void GlfwGetWindowSize(global::System.IntPtr window, int* width, int* height);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetWindowSizeLimits")]
            internal static extern void GlfwSetWindowSizeLimits(global::System.IntPtr window, int minwidth, int minheight, int maxwidth, int maxheight);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetWindowAspectRatio")]
            internal static extern void GlfwSetWindowAspectRatio(global::System.IntPtr window, int numer, int denom);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetWindowSize")]
            internal static extern void GlfwSetWindowSize(global::System.IntPtr window, int width, int height);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetFramebufferSize")]
            internal static extern void GlfwGetFramebufferSize(global::System.IntPtr window, int* width, int* height);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetWindowFrameSize")]
            internal static extern void GlfwGetWindowFrameSize(global::System.IntPtr window, int* left, int* top, int* right, int* bottom);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwIconifyWindow")]
            internal static extern void GlfwIconifyWindow(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwRestoreWindow")]
            internal static extern void GlfwRestoreWindow(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwMaximizeWindow")]
            internal static extern void GlfwMaximizeWindow(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwShowWindow")]
            internal static extern void GlfwShowWindow(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwHideWindow")]
            internal static extern void GlfwHideWindow(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwFocusWindow")]
            internal static extern void GlfwFocusWindow(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetWindowMonitor")]
            internal static extern global::System.IntPtr GlfwGetWindowMonitor(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetWindowMonitor")]
            internal static extern void GlfwSetWindowMonitor(global::System.IntPtr window, global::System.IntPtr monitor, int xpos, int ypos, int width, int height, int refreshRate);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetWindowAttrib")]
            internal static extern int GlfwGetWindowAttrib(global::System.IntPtr window, int attrib);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetWindowUserPointer")]
            internal static extern void GlfwSetWindowUserPointer(global::System.IntPtr window, global::System.IntPtr pointer);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetWindowUserPointer")]
            internal static extern global::System.IntPtr GlfwGetWindowUserPointer(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetWindowPosCallback")]
            internal static extern global::System.IntPtr GlfwSetWindowPosCallback(global::System.IntPtr window, global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetWindowSizeCallback")]
            internal static extern global::System.IntPtr GlfwSetWindowSizeCallback(global::System.IntPtr window, global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetWindowCloseCallback")]
            internal static extern global::System.IntPtr GlfwSetWindowCloseCallback(global::System.IntPtr window, global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetWindowRefreshCallback")]
            internal static extern global::System.IntPtr GlfwSetWindowRefreshCallback(global::System.IntPtr window, global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetWindowFocusCallback")]
            internal static extern global::System.IntPtr GlfwSetWindowFocusCallback(global::System.IntPtr window, global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetWindowIconifyCallback")]
            internal static extern global::System.IntPtr GlfwSetWindowIconifyCallback(global::System.IntPtr window, global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetFramebufferSizeCallback")]
            internal static extern global::System.IntPtr GlfwSetFramebufferSizeCallback(global::System.IntPtr window, global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwPollEvents")]
            internal static extern void GlfwPollEvents();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwWaitEvents")]
            internal static extern void GlfwWaitEvents();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwWaitEventsTimeout")]
            internal static extern void GlfwWaitEventsTimeout(double timeout);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwPostEmptyEvent")]
            internal static extern void GlfwPostEmptyEvent();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetInputMode")]
            internal static extern int GlfwGetInputMode(global::System.IntPtr window, int mode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetInputMode")]
            internal static extern void GlfwSetInputMode(global::System.IntPtr window, int mode, int value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetKeyName")]
            internal static extern global::System.IntPtr GlfwGetKeyName(int key, int scancode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetKey")]
            internal static extern int GlfwGetKey(global::System.IntPtr window, int key);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetMouseButton")]
            internal static extern int GlfwGetMouseButton(global::System.IntPtr window, int button);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetCursorPos")]
            internal static extern void GlfwGetCursorPos(global::System.IntPtr window, double* xpos, double* ypos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetCursorPos")]
            internal static extern void GlfwSetCursorPos(global::System.IntPtr window, double xpos, double ypos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwCreateCursor")]
            internal static extern global::System.IntPtr GlfwCreateCursor(global::System.IntPtr image, int xhot, int yhot);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwCreateStandardCursor")]
            internal static extern global::System.IntPtr GlfwCreateStandardCursor(int shape);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwDestroyCursor")]
            internal static extern void GlfwDestroyCursor(global::System.IntPtr cursor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetCursor")]
            internal static extern void GlfwSetCursor(global::System.IntPtr window, global::System.IntPtr cursor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetKeyCallback")]
            internal static extern global::System.IntPtr GlfwSetKeyCallback(global::System.IntPtr window, global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetCharCallback")]
            internal static extern global::System.IntPtr GlfwSetCharCallback(global::System.IntPtr window, global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetCharModsCallback")]
            internal static extern global::System.IntPtr GlfwSetCharModsCallback(global::System.IntPtr window, global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetMouseButtonCallback")]
            internal static extern global::System.IntPtr GlfwSetMouseButtonCallback(global::System.IntPtr window, global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetCursorPosCallback")]
            internal static extern global::System.IntPtr GlfwSetCursorPosCallback(global::System.IntPtr window, global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetCursorEnterCallback")]
            internal static extern global::System.IntPtr GlfwSetCursorEnterCallback(global::System.IntPtr window, global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetScrollCallback")]
            internal static extern global::System.IntPtr GlfwSetScrollCallback(global::System.IntPtr window, global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetDropCallback")]
            internal static extern global::System.IntPtr GlfwSetDropCallback(global::System.IntPtr window, global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwJoystickPresent")]
            internal static extern int GlfwJoystickPresent(int joy);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetJoystickAxes")]
            internal static extern float* GlfwGetJoystickAxes(int joy, int* count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetJoystickButtons")]
            internal static extern byte* GlfwGetJoystickButtons(int joy, int* count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetJoystickName")]
            internal static extern global::System.IntPtr GlfwGetJoystickName(int joy);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetJoystickCallback")]
            internal static extern global::System.IntPtr GlfwSetJoystickCallback(global::System.IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetClipboardString")]
            internal static extern void GlfwSetClipboardString(global::System.IntPtr window, [MarshalAs(UnmanagedType.LPStr)] string @string);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetClipboardString")]
            internal static extern global::System.IntPtr GlfwGetClipboardString(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetTime")]
            internal static extern double GlfwGetTime();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSetTime")]
            internal static extern void GlfwSetTime(double time);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetTimerValue")]
            internal static extern ulong GlfwGetTimerValue();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetTimerFrequency")]
            internal static extern ulong GlfwGetTimerFrequency();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwMakeContextCurrent")]
            internal static extern void GlfwMakeContextCurrent(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetCurrentContext")]
            internal static extern global::System.IntPtr GlfwGetCurrentContext();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSwapBuffers")]
            internal static extern void GlfwSwapBuffers(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwSwapInterval")]
            internal static extern void GlfwSwapInterval(int interval);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwExtensionSupported")]
            internal static extern int GlfwExtensionSupported([MarshalAs(UnmanagedType.LPStr)] string extension);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetProcAddress")]
            internal static extern global::System.IntPtr GlfwGetProcAddress([MarshalAs(UnmanagedType.LPStr)] string procname);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwVulkanSupported")]
            internal static extern int GlfwVulkanSupported();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="glfwGetRequiredInstanceExtensions")]
            internal static extern sbyte** GlfwGetRequiredInstanceExtensions(uint* count);
        }

        /// <summary>Initializes the GLFW library.</summary>
        /// <returns>
        /// <para>`GLFW_TRUE` if successful, or `GLFW_FALSE` if an</para>
        /// <para>[error](</para>
        /// <para>Possible errors include</para>
        /// </returns>
        /// <remarks>
        /// <para>This function initializes the GLFW library.  Before most GLFW functions can</para>
        /// <para>be used, GLFW must be initialized, and before an application terminates GLFW</para>
        /// <para>should be terminated in order to free any resources allocated during or</para>
        /// <para>after initialization.</para>
        /// <para>If this function fails, it calls</para>
        /// <para>succeeds, you should call</para>
        /// <para>Additional calls to this function after successful initialization but before</para>
        /// <para>termination will return `GLFW_TRUE` immediately.</para>
        /// <para>This function will change the current directory of the</para>
        /// <para>application to the `Contents/Resources` subdirectory of the application's</para>
        /// <para>bundle, if present.  This can be disabled with a</para>
        /// <para>[compile-time option](</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>glfwTerminate</para>
        /// <para>Added in version 1.0.</para>
        /// </remarks>
        public static int GlfwInit()
        {
            var __ret = __Internal.GlfwInit();
            return __ret;
        }

        /// <summary>Terminates the GLFW library.</summary>
        /// <remarks>
        /// <para>This function destroys all remaining windows and cursors, restores any</para>
        /// <para>modified gamma ramps and frees any other allocated resources.  Once this</para>
        /// <para>function is called, you must again call</para>
        /// <para>you will be able to use most GLFW functions.</para>
        /// <para>If GLFW has been successfully initialized, this function should be called</para>
        /// <para>before the application exits.  If initialization fails, there is no need to</para>
        /// <para>call this function, as it is called by</para>
        /// <para>failure.</para>
        /// <para>Possible errors include</para>
        /// <para>This function may be called before</para>
        /// <para>The contexts of any remaining windows must not be current on any</para>
        /// <para>other thread when this function is called.</para>
        /// <para>This function must not be called from a callback.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>glfwInit</para>
        /// <para>Added in version 1.0.</para>
        /// </remarks>
        public static void GlfwTerminate()
        {
            __Internal.GlfwTerminate();
        }

        /// <summary>Retrieves the version of the GLFW library.</summary>
        /// <param name="major">Where to store the major version number, or `NULL`.</param>
        /// <param name="minor">Where to store the minor version number, or `NULL`.</param>
        /// <param name="rev">Where to store the revision number, or `NULL`.</param>
        /// <remarks>
        /// <para>This function retrieves the major, minor and revision numbers of the GLFW</para>
        /// <para>library.  It is intended for when you are using GLFW as a shared library and</para>
        /// <para>want to ensure that you are using the minimum required version.</para>
        /// <para>Any or all of the version arguments may be `NULL`.</para>
        /// <para>None.</para>
        /// <para>This function may be called before</para>
        /// <para>This function may be called from any thread.</para>
        /// <para>glfwGetVersionString</para>
        /// <para>Added in version 1.0.</para>
        /// </remarks>
        public static void GlfwGetVersion(ref int major, ref int minor, ref int rev)
        {
            fixed (int* __refParamPtr0 = &major)
            {
                var __arg0 = __refParamPtr0;
                fixed (int* __refParamPtr1 = &minor)
                {
                    var __arg1 = __refParamPtr1;
                    fixed (int* __refParamPtr2 = &rev)
                    {
                        var __arg2 = __refParamPtr2;
                        __Internal.GlfwGetVersion(__arg0, __arg1, __arg2);
                    }
                }
            }
        }

        /// <summary>Returns a string describing the compile-time configuration.</summary>
        /// <returns>
        /// <para>The ASCII encoded GLFW version string.</para>
        /// <para>None.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns the compile-time generated</para>
        /// <para>[version string](</para>
        /// <para>describes the version, platform, compiler and any platform-specific</para>
        /// <para>compile-time options.  It should not be confused with the OpenGL or OpenGL</para>
        /// <para>ES version string, queried with `glGetString`.</para>
        /// <para>__Do not use the version string__ to parse the GLFW library version.  The</para>
        /// <para>binary in numerical format.</para>
        /// <para>This function may be called before</para>
        /// <para>The returned string is static and compile-time generated.</para>
        /// <para>This function may be called from any thread.</para>
        /// <para>glfwGetVersion</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static string GlfwGetVersionString()
        {
            var __ret = __Internal.GlfwGetVersionString();
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>Sets the error callback.</summary>
        /// <param name="cbfun">
        /// <para>The new callback, or `NULL` to remove the currently set</para>
        /// <para>callback.</para>
        /// </param>
        /// <returns>
        /// <para>The previously set callback, or `NULL` if no callback was set.</para>
        /// <para>None.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function sets the error callback, which is called with an error code</para>
        /// <para>and a human-readable description each time a GLFW error occurs.</para>
        /// <para>The error callback is called on the thread where the error occurred.  If you</para>
        /// <para>are using GLFW from multiple threads, your error callback needs to be</para>
        /// <para>written accordingly.</para>
        /// <para>Because the description string may have been generated specifically for that</para>
        /// <para>error, it is not guaranteed to be valid after the callback has returned.  If</para>
        /// <para>you wish to use it after the callback returns, you need to make a copy.</para>
        /// <para>Once set, the error callback remains set even after the library has been</para>
        /// <para>terminated.</para>
        /// <para>This function may be called before</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWerrorfun GlfwSetErrorCallback(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWerrorfun cbfun)
        {
            var __arg0 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.GlfwSetErrorCallback(__arg0);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWerrorfun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWerrorfun));
        }

        /// <summary>Returns the currently connected monitors.</summary>
        /// <param name="count">
        /// <para>Where to store the number of monitors in the returned</para>
        /// <para>array.  This is set to zero if an error occurred.</para>
        /// </param>
        /// <returns>
        /// <para>An array of monitor handles, or `NULL` if no monitors were found or</para>
        /// <para>if an [error](</para>
        /// <para>Possible errors include</para>
        /// <para>The returned array is allocated and freed by GLFW.  You</para>
        /// <para>should not free it yourself.  It is guaranteed to be valid only until the</para>
        /// <para>monitor configuration changes or the library is terminated.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns an array of handles for all currently connected</para>
        /// <para>monitors.  The primary monitor is always first in the returned array.  If no</para>
        /// <para>monitors were found, this function returns `NULL`.</para>
        /// <para>glfwGetPrimaryMonitor</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWmonitor GlfwGetMonitors(ref int count)
        {
            fixed (int* __refParamPtr0 = &count)
            {
                var __arg0 = __refParamPtr0;
                var __ret = __Internal.GlfwGetMonitors(__arg0);
                global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWmonitor __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWmonitor.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWmonitor) global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWmonitor.NativeToManagedMap[__ret];
                else __result0 = global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWmonitor.__CreateInstance(__ret);
                return __result0;
            }
        }

        /// <summary>Returns the primary monitor.</summary>
        /// <returns>
        /// <para>The primary monitor, or `NULL` if no monitors were found or if an</para>
        /// <para>[error](</para>
        /// <para>Possible errors include</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns the primary monitor.  This is usually the monitor</para>
        /// <para>where elements like the task bar or global menu bar are located.</para>
        /// <para>The primary monitor is always first in the array returned by</para>
        /// <para>glfwGetMonitors.</para>
        /// <para>glfwGetMonitors</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWmonitor GlfwGetPrimaryMonitor()
        {
            var __ret = __Internal.GlfwGetPrimaryMonitor();
            global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWmonitor __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWmonitor.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWmonitor) global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWmonitor.NativeToManagedMap[__ret];
            else __result0 = global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWmonitor.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Returns the position of the monitor's viewport on the virtual screen.</summary>
        /// <param name="monitor">The monitor to query.</param>
        /// <param name="xpos">Where to store the monitor x-coordinate, or `NULL`.</param>
        /// <param name="ypos">Where to store the monitor y-coordinate, or `NULL`.</param>
        /// <remarks>
        /// <para>This function returns the position, in screen coordinates, of the upper-left</para>
        /// <para>corner of the specified monitor.</para>
        /// <para>Any or all of the position arguments may be `NULL`.  If an error occurs, all</para>
        /// <para>non-`NULL` position arguments will be set to zero.</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_PLATFORM_ERROR.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static void GlfwGetMonitorPos(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWmonitor monitor, ref int xpos, ref int ypos)
        {
            var __arg0 = ReferenceEquals(monitor, null) ? global::System.IntPtr.Zero : monitor.__Instance;
            fixed (int* __refParamPtr1 = &xpos)
            {
                var __arg1 = __refParamPtr1;
                fixed (int* __refParamPtr2 = &ypos)
                {
                    var __arg2 = __refParamPtr2;
                    __Internal.GlfwGetMonitorPos(__arg0, __arg1, __arg2);
                }
            }
        }

        /// <summary>Returns the physical size of the monitor.</summary>
        /// <param name="monitor">The monitor to query.</param>
        /// <param name="widthMM">
        /// <para>Where to store the width, in millimetres, of the</para>
        /// <para>monitor's display area, or `NULL`.</para>
        /// </param>
        /// <param name="heightMM">
        /// <para>Where to store the height, in millimetres, of the</para>
        /// <para>monitor's display area, or `NULL`.</para>
        /// </param>
        /// <remarks>
        /// <para>This function returns the size, in millimetres, of the display area of the</para>
        /// <para>specified monitor.</para>
        /// <para>Some systems do not provide accurate monitor size information, either</para>
        /// <para>because the monitor</para>
        /// <para>[EDID](https://en.wikipedia.org/wiki/Extended_display_identification_data)</para>
        /// <para>data is incorrect or because the driver does not report it accurately.</para>
        /// <para>Any or all of the size arguments may be `NULL`.  If an error occurs, all</para>
        /// <para>non-`NULL` size arguments will be set to zero.</para>
        /// <para>Possible errors include</para>
        /// <para>calculates the returned physical size from the</para>
        /// <para>current resolution and system DPI instead of querying the monitor EDID data.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static void GlfwGetMonitorPhysicalSize(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWmonitor monitor, ref int widthMM, ref int heightMM)
        {
            var __arg0 = ReferenceEquals(monitor, null) ? global::System.IntPtr.Zero : monitor.__Instance;
            fixed (int* __refParamPtr1 = &widthMM)
            {
                var __arg1 = __refParamPtr1;
                fixed (int* __refParamPtr2 = &heightMM)
                {
                    var __arg2 = __refParamPtr2;
                    __Internal.GlfwGetMonitorPhysicalSize(__arg0, __arg1, __arg2);
                }
            }
        }

        /// <summary>Returns the name of the specified monitor.</summary>
        /// <param name="monitor">The monitor to query.</param>
        /// <returns>
        /// <para>The UTF-8 encoded name of the monitor, or `NULL` if an</para>
        /// <para>[error](</para>
        /// <para>Possible errors include</para>
        /// <para>The returned string is allocated and freed by GLFW.  You</para>
        /// <para>should not free it yourself.  It is valid until the specified monitor is</para>
        /// <para>disconnected or the library is terminated.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns a human-readable name, encoded as UTF-8, of the</para>
        /// <para>specified monitor.  The name typically reflects the make and model of the</para>
        /// <para>monitor and is not guaranteed to be unique among the connected monitors.</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static string GlfwGetMonitorName(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWmonitor monitor)
        {
            var __arg0 = ReferenceEquals(monitor, null) ? global::System.IntPtr.Zero : monitor.__Instance;
            var __ret = __Internal.GlfwGetMonitorName(__arg0);
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>Sets the monitor configuration callback.</summary>
        /// <param name="cbfun">
        /// <para>The new callback, or `NULL` to remove the currently set</para>
        /// <para>callback.</para>
        /// </param>
        /// <returns>
        /// <para>The previously set callback, or `NULL` if no callback was set or the</para>
        /// <para>library had not been [initialized](</para>
        /// <para>Possible errors include</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function sets the monitor configuration callback, or removes the</para>
        /// <para>currently set callback.  This is called when a monitor is connected to or</para>
        /// <para>disconnected from the system.</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWmonitorfun GlfwSetMonitorCallback(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWmonitorfun cbfun)
        {
            var __arg0 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.GlfwSetMonitorCallback(__arg0);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWmonitorfun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWmonitorfun));
        }

        /// <summary>Returns the available video modes for the specified monitor.</summary>
        /// <param name="monitor">The monitor to query.</param>
        /// <param name="count">
        /// <para>Where to store the number of video modes in the returned</para>
        /// <para>array.  This is set to zero if an error occurred.</para>
        /// </param>
        /// <returns>
        /// <para>An array of video modes, or `NULL` if an</para>
        /// <para>[error](</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_PLATFORM_ERROR.</para>
        /// <para>The returned array is allocated and freed by GLFW.  You</para>
        /// <para>should not free it yourself.  It is valid until the specified monitor is</para>
        /// <para>disconnected, this function is called again for that monitor or the library</para>
        /// <para>is terminated.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns an array of all video modes supported by the specified</para>
        /// <para>monitor.  The returned array is sorted in ascending order, first by color</para>
        /// <para>bit depth (the sum of all channel depths) and then by resolution area (the</para>
        /// <para>product of width and height).</para>
        /// <para>glfwGetVideoMode</para>
        /// <para>Added in version 1.0.</para>
        /// <para>Changed to return an array of modes for a specific monitor.</para>
        /// </remarks>
        public static global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWvidmode GlfwGetVideoModes(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWmonitor monitor, ref int count)
        {
            var __arg0 = ReferenceEquals(monitor, null) ? global::System.IntPtr.Zero : monitor.__Instance;
            fixed (int* __refParamPtr1 = &count)
            {
                var __arg1 = __refParamPtr1;
                var __ret = __Internal.GlfwGetVideoModes(__arg0, __arg1);
                global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWvidmode __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWvidmode.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWvidmode) global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWvidmode.NativeToManagedMap[__ret];
                else __result0 = global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWvidmode.__CreateInstance(__ret);
                return __result0;
            }
        }

        /// <summary>Returns the current mode of the specified monitor.</summary>
        /// <param name="monitor">The monitor to query.</param>
        /// <returns>
        /// <para>The current mode of the monitor, or `NULL` if an</para>
        /// <para>[error](</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_PLATFORM_ERROR.</para>
        /// <para>The returned array is allocated and freed by GLFW.  You</para>
        /// <para>should not free it yourself.  It is valid until the specified monitor is</para>
        /// <para>disconnected or the library is terminated.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns the current video mode of the specified monitor.  If</para>
        /// <para>you have created a full screen window for that monitor, the return value</para>
        /// <para>will depend on whether that window is iconified.</para>
        /// <para>glfwGetVideoModes</para>
        /// <para>Added in version 3.0.  Replaces `glfwGetDesktopMode`.</para>
        /// </remarks>
        public static global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWvidmode GlfwGetVideoMode(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWmonitor monitor)
        {
            var __arg0 = ReferenceEquals(monitor, null) ? global::System.IntPtr.Zero : monitor.__Instance;
            var __ret = __Internal.GlfwGetVideoMode(__arg0);
            global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWvidmode __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWvidmode.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWvidmode) global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWvidmode.NativeToManagedMap[__ret];
            else __result0 = global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWvidmode.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Generates a gamma ramp and sets it for the specified monitor.</summary>
        /// <param name="monitor">The monitor whose gamma ramp to set.</param>
        /// <param name="gamma">The desired exponent.</param>
        /// <remarks>
        /// <para>This function generates a 256-element gamma ramp from the specified exponent</para>
        /// <para>and then calls</para>
        /// <para>number greater than zero.</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_INVALID_VALUE and</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static void GlfwSetGamma(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWmonitor monitor, float gamma)
        {
            var __arg0 = ReferenceEquals(monitor, null) ? global::System.IntPtr.Zero : monitor.__Instance;
            __Internal.GlfwSetGamma(__arg0, gamma);
        }

        /// <summary>Returns the current gamma ramp for the specified monitor.</summary>
        /// <param name="monitor">The monitor to query.</param>
        /// <returns>
        /// <para>The current gamma ramp, or `NULL` if an</para>
        /// <para>[error](</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_PLATFORM_ERROR.</para>
        /// <para>The returned structure and its arrays are allocated and</para>
        /// <para>freed by GLFW.  You should not free them yourself.  They are valid until the</para>
        /// <para>specified monitor is disconnected, this function is called again for that</para>
        /// <para>monitor or the library is terminated.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns the current gamma ramp of the specified monitor.</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWgammaramp GlfwGetGammaRamp(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWmonitor monitor)
        {
            var __arg0 = ReferenceEquals(monitor, null) ? global::System.IntPtr.Zero : monitor.__Instance;
            var __ret = __Internal.GlfwGetGammaRamp(__arg0);
            global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWgammaramp __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWgammaramp.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWgammaramp) global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWgammaramp.NativeToManagedMap[__ret];
            else __result0 = global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWgammaramp.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Sets the current gamma ramp for the specified monitor.</summary>
        /// <param name="monitor">The monitor whose gamma ramp to set.</param>
        /// <param name="ramp">The gamma ramp to use.</param>
        /// <remarks>
        /// <para>This function sets the current gamma ramp for the specified monitor.  The</para>
        /// <para>original gamma ramp for that monitor is saved by GLFW the first time this</para>
        /// <para>function is called and is restored by</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_PLATFORM_ERROR.</para>
        /// <para>Gamma ramp sizes other than 256 are not supported by all platforms</para>
        /// <para>or graphics hardware.</para>
        /// <para>The gamma ramp size must be 256.</para>
        /// <para>The specified gamma ramp is copied before this function</para>
        /// <para>returns.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static void GlfwSetGammaRamp(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWmonitor monitor, global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWgammaramp ramp)
        {
            var __arg0 = ReferenceEquals(monitor, null) ? global::System.IntPtr.Zero : monitor.__Instance;
            var __arg1 = ReferenceEquals(ramp, null) ? global::System.IntPtr.Zero : ramp.__Instance;
            __Internal.GlfwSetGammaRamp(__arg0, __arg1);
        }

        /// <summary>Resets all window hints to their default values.</summary>
        /// <remarks>
        /// <para>This function resets all window hints to their</para>
        /// <para>[default values](</para>
        /// <para>Possible errors include</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>glfwWindowHint</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static void GlfwDefaultWindowHints()
        {
            __Internal.GlfwDefaultWindowHints();
        }

        /// <summary>Sets the specified window hint to the desired value.</summary>
        /// <param name="hint">The [window hint](</param>
        /// <param name="value">The new value of the window hint.</param>
        /// <remarks>
        /// <para>This function sets hints for the next call to</para>
        /// <para>hints, once set, retain their values until changed by a call to</para>
        /// <para>glfwWindowHint or</para>
        /// <para>terminated.</para>
        /// <para>This function does not check whether the specified hint values are valid.</para>
        /// <para>If you set hints to invalid values this will instead be reported by the next</para>
        /// <para>call to</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_INVALID_ENUM.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>glfwDefaultWindowHints</para>
        /// <para>Added in version 3.0.  Replaces `glfwOpenWindowHint`.</para>
        /// </remarks>
        public static void GlfwWindowHint(int hint, int value)
        {
            __Internal.GlfwWindowHint(hint, value);
        }

        /// <summary>Creates a window and its associated context.</summary>
        /// <param name="width">
        /// <para>The desired width, in screen coordinates, of the window.</para>
        /// <para>This must be greater than zero.</para>
        /// </param>
        /// <param name="height">
        /// <para>The desired height, in screen coordinates, of the window.</para>
        /// <para>This must be greater than zero.</para>
        /// </param>
        /// <param name="title">The initial, UTF-8 encoded window title.</param>
        /// <param name="monitor">
        /// <para>The monitor to use for full screen mode, or `NULL` for</para>
        /// <para>windowed mode.</para>
        /// </param>
        /// <param name="share">
        /// <para>The window whose context to share resources with, or `NULL`</para>
        /// <para>to not share resources.</para>
        /// </param>
        /// <returns>
        /// <para>The handle of the created window, or `NULL` if an</para>
        /// <para>[error](</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_INVALID_ENUM,</para>
        /// <para>GLFW_VERSION_UNAVAILABLE,</para>
        /// <para>GLFW_PLATFORM_ERROR.</para>
        /// </returns>
        /// <remarks>
        /// <para>Due to the asynchronous nature of X11, it may take a moment for</para>
        /// <para>a window to reach its requested state.  This means you may not be able to</para>
        /// <para>query the final size, position or other attributes directly after window</para>
        /// <para>creation.</para>
        /// <para>This function must not be called from a callback.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Some window managers will not respect the placement of</para>
        /// <para>initially hidden windows.</para>
        /// <para>On OS X 10.10 and later the window frame will not be rendered</para>
        /// <para>at full resolution on Retina displays unless the `NSHighResolutionCapable`</para>
        /// <para>key is enabled in the application bundle's `Info.plist`.  For more</para>
        /// <para>information, see</para>
        /// <para>[High Resolution Guidelines for OS X](https://developer.apple.com/library/mac/documentation/GraphicsAnimation/Conceptual/HighResolutionOSX/Explained/Explained.html)</para>
        /// <para>in the Mac Developer Library.  The GLFW test and example programs use</para>
        /// <para>a custom `Info.plist` template for this, which can be found as</para>
        /// <para>`CMake/MacOSXBundleInfo.plist.in` in the source tree.</para>
        /// <para>The first time a window is created the menu bar is populated</para>
        /// <para>with common commands like Hide, Quit and About.  The About entry opens</para>
        /// <para>a minimal about dialog with information from the application's bundle.  The</para>
        /// <para>menu bar can be disabled with a</para>
        /// <para>[compile-time option](</para>
        /// <para>Window creation will fail if the Microsoft GDI software</para>
        /// <para>OpenGL implementation is the only one available.</para>
        /// <para>The context to share resources with must not be current on</para>
        /// <para>any other thread.</para>
        /// <para>If the executable has an icon resource named `GLFW_ICON,` it</para>
        /// <para>will be set as the initial icon for the window.  If no such icon is present,</para>
        /// <para>the `IDI_WINLOGO` icon will be used instead.  To set a different icon, see</para>
        /// <para>This function creates a window and its associated OpenGL or OpenGL ES</para>
        /// <para>context.  Most of the options controlling how the window and its context</para>
        /// <para>should be created are specified with [window hints](</para>
        /// <para>Successful creation does not change which context is current.  Before you</para>
        /// <para>can use the newly created context, you need to</para>
        /// <para>[make it current](</para>
        /// <para>parameter, see</para>
        /// <para>The created window, framebuffer and context may differ from what you</para>
        /// <para>requested, as not all parameters and hints are</para>
        /// <para>[hard constraints](</para>
        /// <para>window, especially for full screen windows.  To query the actual attributes</para>
        /// <para>of the created window, framebuffer and context, see</para>
        /// <para>glfwGetWindowAttrib,</para>
        /// <para>To create a full screen window, you need to specify the monitor the window</para>
        /// <para>will cover.  If no monitor is specified, the window will be windowed mode.</para>
        /// <para>Unless you have a way for the user to choose a specific monitor, it is</para>
        /// <para>recommended that you pick the primary monitor.  For more information on how</para>
        /// <para>to query connected monitors, see</para>
        /// <para>For full screen windows, the specified size becomes the resolution of the</para>
        /// <para>window's _desired video mode_.  As long as a full screen window is not</para>
        /// <para>iconified, the supported video mode most closely matching the desired video</para>
        /// <para>mode is set for the specified monitor.  For more information about full</para>
        /// <para>screen windows, including the creation of so called _windowed full screen_</para>
        /// <para>or _borderless full screen_ windows, see</para>
        /// <para>Once you have created the window, you can switch it between windowed and</para>
        /// <para>full screen mode with</para>
        /// <para>OpenGL or OpenGL ES context, it will be unaffected.</para>
        /// <para>By default, newly created windows use the placement recommended by the</para>
        /// <para>window system.  To create the window at a specific position, make it</para>
        /// <para>initially invisible using the [GLFW_VISIBLE](</para>
        /// <para>hint, set its [position](</para>
        /// <para>it.</para>
        /// <para>As long as at least one full screen window is not iconified, the screensaver</para>
        /// <para>is prohibited from starting.</para>
        /// <para>Window systems put limits on window sizes.  Very large or very small window</para>
        /// <para>dimensions may be overridden by the window system on creation.  Check the</para>
        /// <para>actual [size](</para>
        /// <para>The [swap interval](</para>
        /// <para>the initial value may vary depending on driver settings and defaults.</para>
        /// <para>The GLFW window has no icon, as it is not a document</para>
        /// <para>window, but the dock icon will be the same as the application bundle's icon.</para>
        /// <para>For more information on bundles, see the</para>
        /// <para>[Bundle Programming Guide](https://developer.apple.com/library/mac/documentation/CoreFoundation/Conceptual/CFBundles/)</para>
        /// <para>in the Mac Developer Library.</para>
        /// <para>glfwDestroyWindow</para>
        /// <para>Added in version 3.0.  Replaces `glfwOpenWindow`.</para>
        /// </remarks>
        public static global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow GlfwCreateWindow(int width, int height, string title, global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWmonitor monitor, global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow share)
        {
            var __arg3 = ReferenceEquals(monitor, null) ? global::System.IntPtr.Zero : monitor.__Instance;
            var __arg4 = ReferenceEquals(share, null) ? global::System.IntPtr.Zero : share.__Instance;
            var __ret = __Internal.GlfwCreateWindow(width, height, title, __arg3, __arg4);
            global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow) global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow.NativeToManagedMap[__ret];
            else __result0 = global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Destroys the specified window and its context.</summary>
        /// <param name="window">The window to destroy.</param>
        /// <remarks>
        /// <para>This function destroys the specified window and its context.  On calling</para>
        /// <para>this function, no further callbacks will be called for that window.</para>
        /// <para>If the context of the specified window is current on the main thread, it is</para>
        /// <para>detached before being destroyed.</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_PLATFORM_ERROR.</para>
        /// <para>The context of the specified window must not be current on any other</para>
        /// <para>thread when this function is called.</para>
        /// <para>This function must not be called from a callback.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>glfwCreateWindow</para>
        /// <para>Added in version 3.0.  Replaces `glfwCloseWindow`.</para>
        /// </remarks>
        public static void GlfwDestroyWindow(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.GlfwDestroyWindow(__arg0);
        }

        /// <summary>Checks the close flag of the specified window.</summary>
        /// <param name="window">The window to query.</param>
        /// <returns>
        /// <para>The value of the close flag.</para>
        /// <para>Possible errors include</para>
        /// <para>This function may be called from any thread.  Access is not</para>
        /// <para>synchronized.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns the value of the close flag of the specified window.</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static int GlfwWindowShouldClose(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GlfwWindowShouldClose(__arg0);
            return __ret;
        }

        /// <summary>Sets the close flag of the specified window.</summary>
        /// <param name="window">The window whose flag to change.</param>
        /// <param name="value">The new value.</param>
        /// <remarks>
        /// <para>This function sets the value of the close flag of the specified window.</para>
        /// <para>This can be used to override the user's attempt to close the window, or</para>
        /// <para>to signal that it should be closed.</para>
        /// <para>Possible errors include</para>
        /// <para>This function may be called from any thread.  Access is not</para>
        /// <para>synchronized.</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static void GlfwSetWindowShouldClose(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow window, int value)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.GlfwSetWindowShouldClose(__arg0, value);
        }

        /// <summary>Sets the title of the specified window.</summary>
        /// <param name="window">The window whose title to change.</param>
        /// <param name="title">The UTF-8 encoded window title.</param>
        /// <remarks>
        /// <para>This function sets the window title, encoded as UTF-8, of the specified</para>
        /// <para>window.</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_PLATFORM_ERROR.</para>
        /// <para>The window title will not be updated until the next time you</para>
        /// <para>process events.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 1.0.</para>
        /// <para>Added window handle parameter.</para>
        /// </remarks>
        public static void GlfwSetWindowTitle(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow window, string title)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.GlfwSetWindowTitle(__arg0, title);
        }

        /// <summary>Sets the icon for the specified window.</summary>
        /// <param name="window">The window whose icon to set.</param>
        /// <param name="count">
        /// <para>The number of images in the specified array, or zero to</para>
        /// <para>revert to the default window icon.</para>
        /// </param>
        /// <param name="images">
        /// <para>The images to create the icon from.  This is ignored if</para>
        /// <para>count is zero.</para>
        /// </param>
        /// <remarks>
        /// <para>This function sets the icon of the specified window.  If passed an array of</para>
        /// <para>candidate images, those of or closest to the sizes desired by the system are</para>
        /// <para>selected.  If no images are specified, the window reverts to its default</para>
        /// <para>icon.</para>
        /// <para>The desired image sizes varies depending on platform and system settings.</para>
        /// <para>The selected images will be rescaled as needed.  Good sizes include 16x16,</para>
        /// <para>32x32 and 48x48.</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_PLATFORM_ERROR.</para>
        /// <para>The specified image data is copied before this function</para>
        /// <para>returns.</para>
        /// <para>The GLFW window has no icon, as it is not a document</para>
        /// <para>window, so this function does nothing.  The dock icon will be the same as</para>
        /// <para>the application bundle's icon.  For more information on bundles, see the</para>
        /// <para>[Bundle Programming Guide](https://developer.apple.com/library/mac/documentation/CoreFoundation/Conceptual/CFBundles/)</para>
        /// <para>in the Mac Developer Library.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 3.2.</para>
        /// </remarks>
        public static void GlfwSetWindowIcon(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow window, int count, global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWimage images)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg2 = ReferenceEquals(images, null) ? global::System.IntPtr.Zero : images.__Instance;
            __Internal.GlfwSetWindowIcon(__arg0, count, __arg2);
        }

        /// <summary>Retrieves the position of the client area of the specified window.</summary>
        /// <param name="window">The window to query.</param>
        /// <param name="xpos">
        /// <para>Where to store the x-coordinate of the upper-left corner of</para>
        /// <para>the client area, or `NULL`.</para>
        /// </param>
        /// <param name="ypos">
        /// <para>Where to store the y-coordinate of the upper-left corner of</para>
        /// <para>the client area, or `NULL`.</para>
        /// </param>
        /// <remarks>
        /// <para>This function retrieves the position, in screen coordinates, of the</para>
        /// <para>upper-left corner of the client area of the specified window.</para>
        /// <para>Any or all of the position arguments may be `NULL`.  If an error occurs, all</para>
        /// <para>non-`NULL` position arguments will be set to zero.</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_PLATFORM_ERROR.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>glfwSetWindowPos</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static void GlfwGetWindowPos(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow window, ref int xpos, ref int ypos)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            fixed (int* __refParamPtr1 = &xpos)
            {
                var __arg1 = __refParamPtr1;
                fixed (int* __refParamPtr2 = &ypos)
                {
                    var __arg2 = __refParamPtr2;
                    __Internal.GlfwGetWindowPos(__arg0, __arg1, __arg2);
                }
            }
        }

        /// <summary>Sets the position of the client area of the specified window.</summary>
        /// <param name="window">The window to query.</param>
        /// <param name="xpos">The x-coordinate of the upper-left corner of the client area.</param>
        /// <param name="ypos">The y-coordinate of the upper-left corner of the client area.</param>
        /// <remarks>
        /// <para>This function sets the position, in screen coordinates, of the upper-left</para>
        /// <para>corner of the client area of the specified windowed mode window.  If the</para>
        /// <para>window is a full screen window, this function does nothing.</para>
        /// <para>__Do not use this function__ to move an already visible window unless you</para>
        /// <para>have very good reasons for doing so, as it will confuse and annoy the user.</para>
        /// <para>The window manager may put limits on what positions are allowed.  GLFW</para>
        /// <para>cannot and should not override these limits.</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_PLATFORM_ERROR.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>glfwGetWindowPos</para>
        /// <para>Added in version 1.0.</para>
        /// <para>Added window handle parameter.</para>
        /// </remarks>
        public static void GlfwSetWindowPos(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow window, int xpos, int ypos)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.GlfwSetWindowPos(__arg0, xpos, ypos);
        }

        /// <summary>Retrieves the size of the client area of the specified window.</summary>
        /// <param name="window">The window whose size to retrieve.</param>
        /// <param name="width">
        /// <para>Where to store the width, in screen coordinates, of the</para>
        /// <para>client area, or `NULL`.</para>
        /// </param>
        /// <param name="height">
        /// <para>Where to store the height, in screen coordinates, of the</para>
        /// <para>client area, or `NULL`.</para>
        /// </param>
        /// <remarks>
        /// <para>This function retrieves the size, in screen coordinates, of the client area</para>
        /// <para>of the specified window.  If you wish to retrieve the size of the</para>
        /// <para>framebuffer of the window in pixels, see</para>
        /// <para>Any or all of the size arguments may be `NULL`.  If an error occurs, all</para>
        /// <para>non-`NULL` size arguments will be set to zero.</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_PLATFORM_ERROR.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>glfwSetWindowSize</para>
        /// <para>Added in version 1.0.</para>
        /// <para>Added window handle parameter.</para>
        /// </remarks>
        public static void GlfwGetWindowSize(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow window, ref int width, ref int height)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            fixed (int* __refParamPtr1 = &width)
            {
                var __arg1 = __refParamPtr1;
                fixed (int* __refParamPtr2 = &height)
                {
                    var __arg2 = __refParamPtr2;
                    __Internal.GlfwGetWindowSize(__arg0, __arg1, __arg2);
                }
            }
        }

        /// <summary>Sets the size limits of the specified window.</summary>
        /// <param name="window">The window to set limits for.</param>
        /// <param name="minwidth">
        /// <para>The minimum width, in screen coordinates, of the client</para>
        /// <para>area, or `GLFW_DONT_CARE`.</para>
        /// </param>
        /// <param name="minheight">
        /// <para>The minimum height, in screen coordinates, of the</para>
        /// <para>client area, or `GLFW_DONT_CARE`.</para>
        /// </param>
        /// <param name="maxwidth">
        /// <para>The maximum width, in screen coordinates, of the client</para>
        /// <para>area, or `GLFW_DONT_CARE`.</para>
        /// </param>
        /// <param name="maxheight">
        /// <para>The maximum height, in screen coordinates, of the</para>
        /// <para>client area, or `GLFW_DONT_CARE`.</para>
        /// </param>
        /// <remarks>
        /// <para>This function sets the size limits of the client area of the specified</para>
        /// <para>window.  If the window is full screen, the size limits only take effect</para>
        /// <para>once it is made windowed.  If the window is not resizable, this function</para>
        /// <para>does nothing.</para>
        /// <para>The size limits are applied immediately to a windowed mode window and may</para>
        /// <para>cause it to be resized.</para>
        /// <para>The maximum dimensions must be greater than or equal to the minimum</para>
        /// <para>dimensions and all must be greater than or equal to zero.</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_INVALID_VALUE and</para>
        /// <para>If you set size limits and an aspect ratio that conflict, the</para>
        /// <para>results are undefined.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>glfwSetWindowAspectRatio</para>
        /// <para>Added in version 3.2.</para>
        /// </remarks>
        public static void GlfwSetWindowSizeLimits(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow window, int minwidth, int minheight, int maxwidth, int maxheight)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.GlfwSetWindowSizeLimits(__arg0, minwidth, minheight, maxwidth, maxheight);
        }

        /// <summary>Sets the aspect ratio of the specified window.</summary>
        /// <param name="window">The window to set limits for.</param>
        /// <param name="numer">
        /// <para>The numerator of the desired aspect ratio, or</para>
        /// <para>`GLFW_DONT_CARE`.</para>
        /// </param>
        /// <param name="denom">
        /// <para>The denominator of the desired aspect ratio, or</para>
        /// <para>`GLFW_DONT_CARE`.</para>
        /// </param>
        /// <remarks>
        /// <para>This function sets the required aspect ratio of the client area of the</para>
        /// <para>specified window.  If the window is full screen, the aspect ratio only takes</para>
        /// <para>effect once it is made windowed.  If the window is not resizable, this</para>
        /// <para>function does nothing.</para>
        /// <para>The aspect ratio is specified as a numerator and a denominator and both</para>
        /// <para>values must be greater than zero.  For example, the common 16:9 aspect ratio</para>
        /// <para>is specified as 16 and 9, respectively.</para>
        /// <para>If the numerator and denominator is set to `GLFW_DONT_CARE` then the aspect</para>
        /// <para>ratio limit is disabled.</para>
        /// <para>The aspect ratio is applied immediately to a windowed mode window and may</para>
        /// <para>cause it to be resized.</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_INVALID_VALUE and</para>
        /// <para>If you set size limits and an aspect ratio that conflict, the</para>
        /// <para>results are undefined.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>glfwSetWindowSizeLimits</para>
        /// <para>Added in version 3.2.</para>
        /// </remarks>
        public static void GlfwSetWindowAspectRatio(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow window, int numer, int denom)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.GlfwSetWindowAspectRatio(__arg0, numer, denom);
        }

        /// <summary>Sets the size of the client area of the specified window.</summary>
        /// <param name="window">The window to resize.</param>
        /// <param name="width">
        /// <para>The desired width, in screen coordinates, of the window</para>
        /// <para>client area.</para>
        /// </param>
        /// <param name="height">
        /// <para>The desired height, in screen coordinates, of the window</para>
        /// <para>client area.</para>
        /// </param>
        /// <remarks>
        /// <para>This function sets the size, in screen coordinates, of the client area of</para>
        /// <para>the specified window.</para>
        /// <para>For full screen windows, this function updates the resolution of its desired</para>
        /// <para>video mode and switches to the video mode closest to it, without affecting</para>
        /// <para>the window's context.  As the context is unaffected, the bit depths of the</para>
        /// <para>framebuffer remain unchanged.</para>
        /// <para>If you wish to update the refresh rate of the desired video mode in addition</para>
        /// <para>to its resolution, see</para>
        /// <para>The window manager may put limits on what sizes are allowed.  GLFW cannot</para>
        /// <para>and should not override these limits.</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_PLATFORM_ERROR.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>glfwGetWindowSize</para>
        /// <para>glfwSetWindowMonitor</para>
        /// <para>Added in version 1.0.</para>
        /// <para>Added window handle parameter.</para>
        /// </remarks>
        public static void GlfwSetWindowSize(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow window, int width, int height)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.GlfwSetWindowSize(__arg0, width, height);
        }

        /// <summary>Retrieves the size of the framebuffer of the specified window.</summary>
        /// <param name="window">The window whose framebuffer to query.</param>
        /// <param name="width">
        /// <para>Where to store the width, in pixels, of the framebuffer,</para>
        /// <para>or `NULL`.</para>
        /// </param>
        /// <param name="height">
        /// <para>Where to store the height, in pixels, of the framebuffer,</para>
        /// <para>or `NULL`.</para>
        /// </param>
        /// <remarks>
        /// <para>This function retrieves the size, in pixels, of the framebuffer of the</para>
        /// <para>specified window.  If you wish to retrieve the size of the window in screen</para>
        /// <para>coordinates, see</para>
        /// <para>Any or all of the size arguments may be `NULL`.  If an error occurs, all</para>
        /// <para>non-`NULL` size arguments will be set to zero.</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_PLATFORM_ERROR.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>glfwSetFramebufferSizeCallback</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static void GlfwGetFramebufferSize(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow window, ref int width, ref int height)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            fixed (int* __refParamPtr1 = &width)
            {
                var __arg1 = __refParamPtr1;
                fixed (int* __refParamPtr2 = &height)
                {
                    var __arg2 = __refParamPtr2;
                    __Internal.GlfwGetFramebufferSize(__arg0, __arg1, __arg2);
                }
            }
        }

        /// <summary>Retrieves the size of the frame of the window.</summary>
        /// <param name="window">The window whose frame size to query.</param>
        /// <param name="left">
        /// <para>Where to store the size, in screen coordinates, of the left</para>
        /// <para>edge of the window frame, or `NULL`.</para>
        /// </param>
        /// <param name="top">
        /// <para>Where to store the size, in screen coordinates, of the top</para>
        /// <para>edge of the window frame, or `NULL`.</para>
        /// </param>
        /// <param name="right">
        /// <para>Where to store the size, in screen coordinates, of the</para>
        /// <para>right edge of the window frame, or `NULL`.</para>
        /// </param>
        /// <param name="bottom">
        /// <para>Where to store the size, in screen coordinates, of the</para>
        /// <para>bottom edge of the window frame, or `NULL`.</para>
        /// </param>
        /// <remarks>
        /// <para>This function retrieves the size, in screen coordinates, of each edge of the</para>
        /// <para>frame of the specified window.  This size includes the title bar, if the</para>
        /// <para>window has one.  The size of the frame may vary depending on the</para>
        /// <para>[window-related hints](</para>
        /// <para>Because this function retrieves the size of each window frame edge and not</para>
        /// <para>the offset along a particular coordinate axis, the retrieved values will</para>
        /// <para>always be zero or positive.</para>
        /// <para>Any or all of the size arguments may be `NULL`.  If an error occurs, all</para>
        /// <para>non-`NULL` size arguments will be set to zero.</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_PLATFORM_ERROR.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 3.1.</para>
        /// </remarks>
        public static void GlfwGetWindowFrameSize(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow window, ref int left, ref int top, ref int right, ref int bottom)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            fixed (int* __refParamPtr1 = &left)
            {
                var __arg1 = __refParamPtr1;
                fixed (int* __refParamPtr2 = &top)
                {
                    var __arg2 = __refParamPtr2;
                    fixed (int* __refParamPtr3 = &right)
                    {
                        var __arg3 = __refParamPtr3;
                        fixed (int* __refParamPtr4 = &bottom)
                        {
                            var __arg4 = __refParamPtr4;
                            __Internal.GlfwGetWindowFrameSize(__arg0, __arg1, __arg2, __arg3, __arg4);
                        }
                    }
                }
            }
        }

        /// <summary>Iconifies the specified window.</summary>
        /// <param name="window">The window to iconify.</param>
        /// <remarks>
        /// <para>This function iconifies (minimizes) the specified window if it was</para>
        /// <para>previously restored.  If the window is already iconified, this function does</para>
        /// <para>nothing.</para>
        /// <para>If the specified window is a full screen window, the original monitor</para>
        /// <para>resolution is restored until the window is restored.</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_PLATFORM_ERROR.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>glfwRestoreWindow</para>
        /// <para>glfwMaximizeWindow</para>
        /// <para>Added in version 2.1.</para>
        /// <para>Added window handle parameter.</para>
        /// </remarks>
        public static void GlfwIconifyWindow(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.GlfwIconifyWindow(__arg0);
        }

        /// <summary>Restores the specified window.</summary>
        /// <param name="window">The window to restore.</param>
        /// <remarks>
        /// <para>This function restores the specified window if it was previously iconified</para>
        /// <para>(minimized) or maximized.  If the window is already restored, this function</para>
        /// <para>does nothing.</para>
        /// <para>If the specified window is a full screen window, the resolution chosen for</para>
        /// <para>the window is restored on the selected monitor.</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_PLATFORM_ERROR.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>glfwIconifyWindow</para>
        /// <para>glfwMaximizeWindow</para>
        /// <para>Added in version 2.1.</para>
        /// <para>Added window handle parameter.</para>
        /// </remarks>
        public static void GlfwRestoreWindow(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.GlfwRestoreWindow(__arg0);
        }

        /// <summary>Maximizes the specified window.</summary>
        /// <param name="window">The window to maximize.</param>
        /// <remarks>
        /// <para>This function maximizes the specified window if it was previously not</para>
        /// <para>maximized.  If the window is already maximized, this function does nothing.</para>
        /// <para>If the specified window is a full screen window, this function does nothing.</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_PLATFORM_ERROR.</para>
        /// <para>Thread Safety</para>
        /// <para>This function may only be called from the main thread.</para>
        /// <para>glfwIconifyWindow</para>
        /// <para>glfwRestoreWindow</para>
        /// <para>Added in GLFW 3.2.</para>
        /// </remarks>
        public static void GlfwMaximizeWindow(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.GlfwMaximizeWindow(__arg0);
        }

        /// <summary>Makes the specified window visible.</summary>
        /// <param name="window">The window to make visible.</param>
        /// <remarks>
        /// <para>This function makes the specified window visible if it was previously</para>
        /// <para>hidden.  If the window is already visible or is in full screen mode, this</para>
        /// <para>function does nothing.</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_PLATFORM_ERROR.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>glfwHideWindow</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static void GlfwShowWindow(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.GlfwShowWindow(__arg0);
        }

        /// <summary>Hides the specified window.</summary>
        /// <param name="window">The window to hide.</param>
        /// <remarks>
        /// <para>This function hides the specified window if it was previously visible.  If</para>
        /// <para>the window is already hidden or is in full screen mode, this function does</para>
        /// <para>nothing.</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_PLATFORM_ERROR.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>glfwShowWindow</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static void GlfwHideWindow(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.GlfwHideWindow(__arg0);
        }

        /// <summary>Brings the specified window to front and sets input focus.</summary>
        /// <param name="window">The window to give input focus.</param>
        /// <remarks>
        /// <para>This function brings the specified window to front and sets input focus.</para>
        /// <para>The window should already be visible and not iconified.</para>
        /// <para>By default, both windowed and full screen mode windows are focused when</para>
        /// <para>initially created.  Set the [GLFW_FOCUSED](</para>
        /// <para>this behavior.</para>
        /// <para>__Do not use this function__ to steal focus from other applications unless</para>
        /// <para>you are certain that is what the user wants.  Focus stealing can be</para>
        /// <para>extremely disruptive.</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_PLATFORM_ERROR.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 3.2.</para>
        /// </remarks>
        public static void GlfwFocusWindow(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.GlfwFocusWindow(__arg0);
        }

        /// <summary>Returns the monitor that the window uses for full screen mode.</summary>
        /// <param name="window">The window to query.</param>
        /// <returns>
        /// <para>The monitor, or `NULL` if the window is in windowed mode or an</para>
        /// <para>[error](</para>
        /// <para>Possible errors include</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns the handle of the monitor that the specified window is</para>
        /// <para>in full screen on.</para>
        /// <para>glfwSetWindowMonitor</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWmonitor GlfwGetWindowMonitor(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GlfwGetWindowMonitor(__arg0);
            global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWmonitor __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWmonitor.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWmonitor) global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWmonitor.NativeToManagedMap[__ret];
            else __result0 = global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWmonitor.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Sets the mode, monitor, video mode and placement of a window.</summary>
        /// <param name="window">The window whose monitor, size or video mode to set.</param>
        /// <param name="monitor">The desired monitor, or `NULL` to set windowed mode.</param>
        /// <param name="xpos">
        /// <para>The desired x-coordinate of the upper-left corner of the</para>
        /// <para>client area.</para>
        /// </param>
        /// <param name="ypos">
        /// <para>The desired y-coordinate of the upper-left corner of the</para>
        /// <para>client area.</para>
        /// </param>
        /// <param name="width">
        /// <para>The desired with, in screen coordinates, of the client area</para>
        /// <para>or video mode.</para>
        /// </param>
        /// <param name="height">
        /// <para>The desired height, in screen coordinates, of the client</para>
        /// <para>area or video mode.</para>
        /// </param>
        /// <param name="refreshRate">
        /// <para>The desired refresh rate, in Hz, of the video mode,</para>
        /// <para>or `GLFW_DONT_CARE`.</para>
        /// </param>
        /// <remarks>
        /// <para>This function sets the monitor that the window uses for full screen mode or,</para>
        /// <para>if the monitor is `NULL`, makes it windowed mode.</para>
        /// <para>When setting a monitor, this function updates the width, height and refresh</para>
        /// <para>rate of the desired video mode and switches to the video mode closest to it.</para>
        /// <para>The window position is ignored when setting a monitor.</para>
        /// <para>When the monitor is `NULL`, the position, width and height are used to</para>
        /// <para>place the window client area.  The refresh rate is ignored when no monitor</para>
        /// <para>is specified.</para>
        /// <para>If you only wish to update the resolution of a full screen window or the</para>
        /// <para>size of a windowed mode window, see</para>
        /// <para>When a window transitions from full screen to windowed mode, this function</para>
        /// <para>restores any previous window settings such as whether it is decorated,</para>
        /// <para>floating, resizable, has size or aspect ratio limits, etc..</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_PLATFORM_ERROR.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>glfwGetWindowMonitor</para>
        /// <para>glfwSetWindowSize</para>
        /// <para>Added in version 3.2.</para>
        /// </remarks>
        public static void GlfwSetWindowMonitor(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow window, global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWmonitor monitor, int xpos, int ypos, int width, int height, int refreshRate)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = ReferenceEquals(monitor, null) ? global::System.IntPtr.Zero : monitor.__Instance;
            __Internal.GlfwSetWindowMonitor(__arg0, __arg1, xpos, ypos, width, height, refreshRate);
        }

        /// <summary>Returns an attribute of the specified window.</summary>
        /// <param name="window">The window to query.</param>
        /// <param name="attrib">The [window attribute](</param>
        /// <returns>
        /// <para>The value of the attribute, or zero if an</para>
        /// <para>[error](</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_INVALID_ENUM and</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns the value of an attribute of the specified window or</para>
        /// <para>its OpenGL or OpenGL ES context.</para>
        /// <para>return.</para>
        /// <para>Framebuffer related hints are not window attributes.  See</para>
        /// <para>window_attribs_fb for more information.</para>
        /// <para>Zero is a valid value for many window and context related</para>
        /// <para>attributes so you cannot use a return value of zero as an indication of</para>
        /// <para>errors.  However, this function should not fail as long as it is passed</para>
        /// <para>valid arguments and the library has been [initialized](</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 3.0.  Replaces `glfwGetWindowParam` and</para>
        /// <para>`glfwGetGLVersion`.</para>
        /// </remarks>
        public static int GlfwGetWindowAttrib(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow window, int attrib)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GlfwGetWindowAttrib(__arg0, attrib);
            return __ret;
        }

        /// <summary>Sets the user pointer of the specified window.</summary>
        /// <param name="window">The window whose pointer to set.</param>
        /// <param name="pointer">The new value.</param>
        /// <remarks>
        /// <para>This function sets the user-defined pointer of the specified window.  The</para>
        /// <para>current value is retained until the window is destroyed.  The initial value</para>
        /// <para>is `NULL`.</para>
        /// <para>Possible errors include</para>
        /// <para>This function may be called from any thread.  Access is not</para>
        /// <para>synchronized.</para>
        /// <para>glfwGetWindowUserPointer</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static void GlfwSetWindowUserPointer(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow window, global::System.IntPtr pointer)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.GlfwSetWindowUserPointer(__arg0, pointer);
        }

        /// <summary>Returns the user pointer of the specified window.</summary>
        /// <param name="window">The window whose pointer to return.</param>
        /// <remarks>
        /// <para>This function returns the current value of the user-defined pointer of the</para>
        /// <para>specified window.  The initial value is `NULL`.</para>
        /// <para>Possible errors include</para>
        /// <para>This function may be called from any thread.  Access is not</para>
        /// <para>synchronized.</para>
        /// <para>glfwSetWindowUserPointer</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static global::System.IntPtr GlfwGetWindowUserPointer(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GlfwGetWindowUserPointer(__arg0);
            return __ret;
        }

        /// <summary>Sets the position callback for the specified window.</summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="cbfun">
        /// <para>The new callback, or `NULL` to remove the currently set</para>
        /// <para>callback.</para>
        /// </param>
        /// <returns>
        /// <para>The previously set callback, or `NULL` if no callback was set or the</para>
        /// <para>library had not been [initialized](</para>
        /// <para>Possible errors include</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function sets the position callback of the specified window, which is</para>
        /// <para>called when the window is moved.  The callback is provided with the screen</para>
        /// <para>position of the upper-left corner of the client area of the window.</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindowposfun GlfwSetWindowPosCallback(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow window, global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindowposfun cbfun)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.GlfwSetWindowPosCallback(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindowposfun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindowposfun));
        }

        /// <summary>Sets the size callback for the specified window.</summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="cbfun">
        /// <para>The new callback, or `NULL` to remove the currently set</para>
        /// <para>callback.</para>
        /// </param>
        /// <returns>
        /// <para>The previously set callback, or `NULL` if no callback was set or the</para>
        /// <para>library had not been [initialized](</para>
        /// <para>Possible errors include</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function sets the size callback of the specified window, which is</para>
        /// <para>called when the window is resized.  The callback is provided with the size,</para>
        /// <para>in screen coordinates, of the client area of the window.</para>
        /// <para>Added in version 1.0.</para>
        /// <para>Added window handle parameter and return value.</para>
        /// </remarks>
        public static global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindowsizefun GlfwSetWindowSizeCallback(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow window, global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindowsizefun cbfun)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.GlfwSetWindowSizeCallback(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindowsizefun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindowsizefun));
        }

        /// <summary>Sets the close callback for the specified window.</summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="cbfun">
        /// <para>The new callback, or `NULL` to remove the currently set</para>
        /// <para>callback.</para>
        /// </param>
        /// <returns>
        /// <para>The previously set callback, or `NULL` if no callback was set or the</para>
        /// <para>library had not been [initialized](</para>
        /// <para>Possible errors include</para>
        /// </returns>
        /// <remarks>
        /// <para>This function sets the close callback of the specified window, which is</para>
        /// <para>called when the user attempts to close the window, for example by clicking</para>
        /// <para>the close widget in the title bar.</para>
        /// <para>The close flag is set before this callback is called, but you can modify it</para>
        /// <para>at any time with</para>
        /// <para>The close callback is not triggered by</para>
        /// <para>Selecting Quit from the application menu will trigger the close</para>
        /// <para>callback for all windows.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 2.5.</para>
        /// <para>Added window handle parameter and return value.</para>
        /// </remarks>
        public static global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindowclosefun GlfwSetWindowCloseCallback(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow window, global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindowclosefun cbfun)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.GlfwSetWindowCloseCallback(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindowclosefun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindowclosefun));
        }

        /// <summary>Sets the refresh callback for the specified window.</summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="cbfun">
        /// <para>The new callback, or `NULL` to remove the currently set</para>
        /// <para>callback.</para>
        /// </param>
        /// <returns>
        /// <para>The previously set callback, or `NULL` if no callback was set or the</para>
        /// <para>library had not been [initialized](</para>
        /// <para>Possible errors include</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function sets the refresh callback of the specified window, which is</para>
        /// <para>called when the client area of the window needs to be redrawn, for example</para>
        /// <para>if the window has been exposed after having been covered by another window.</para>
        /// <para>On compositing window systems such as Aero, Compiz or Aqua, where the window</para>
        /// <para>contents are saved off-screen, this callback may be called only very</para>
        /// <para>infrequently or never at all.</para>
        /// <para>Added in version 2.5.</para>
        /// <para>Added window handle parameter and return value.</para>
        /// </remarks>
        public static global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindowrefreshfun GlfwSetWindowRefreshCallback(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow window, global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindowrefreshfun cbfun)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.GlfwSetWindowRefreshCallback(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindowrefreshfun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindowrefreshfun));
        }

        /// <summary>Sets the focus callback for the specified window.</summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="cbfun">
        /// <para>The new callback, or `NULL` to remove the currently set</para>
        /// <para>callback.</para>
        /// </param>
        /// <returns>
        /// <para>The previously set callback, or `NULL` if no callback was set or the</para>
        /// <para>library had not been [initialized](</para>
        /// <para>Possible errors include</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function sets the focus callback of the specified window, which is</para>
        /// <para>called when the window gains or loses input focus.</para>
        /// <para>After the focus callback is called for a window that lost input focus,</para>
        /// <para>synthetic key and mouse button release events will be generated for all such</para>
        /// <para>that had been pressed.  For more information, see</para>
        /// <para>and</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindowfocusfun GlfwSetWindowFocusCallback(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow window, global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindowfocusfun cbfun)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.GlfwSetWindowFocusCallback(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindowfocusfun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindowfocusfun));
        }

        /// <summary>Sets the iconify callback for the specified window.</summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="cbfun">
        /// <para>The new callback, or `NULL` to remove the currently set</para>
        /// <para>callback.</para>
        /// </param>
        /// <returns>
        /// <para>The previously set callback, or `NULL` if no callback was set or the</para>
        /// <para>library had not been [initialized](</para>
        /// <para>Possible errors include</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function sets the iconification callback of the specified window, which</para>
        /// <para>is called when the window is iconified or restored.</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindowiconifyfun GlfwSetWindowIconifyCallback(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow window, global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindowiconifyfun cbfun)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.GlfwSetWindowIconifyCallback(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindowiconifyfun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindowiconifyfun));
        }

        /// <summary>Sets the framebuffer resize callback for the specified window.</summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="cbfun">
        /// <para>The new callback, or `NULL` to remove the currently set</para>
        /// <para>callback.</para>
        /// </param>
        /// <returns>
        /// <para>The previously set callback, or `NULL` if no callback was set or the</para>
        /// <para>library had not been [initialized](</para>
        /// <para>Possible errors include</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function sets the framebuffer resize callback of the specified window,</para>
        /// <para>which is called when the framebuffer of the specified window is resized.</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWframebuffersizefun GlfwSetFramebufferSizeCallback(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow window, global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWframebuffersizefun cbfun)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.GlfwSetFramebufferSizeCallback(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWframebuffersizefun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWframebuffersizefun));
        }

        /// <summary>Processes all pending events.</summary>
        /// <remarks>
        /// <para>This function processes only those events that are already in the event</para>
        /// <para>queue and then returns immediately.  Processing events will cause the window</para>
        /// <para>and input callbacks associated with those events to be called.</para>
        /// <para>On some platforms, a window move, resize or menu operation will cause event</para>
        /// <para>processing to block.  This is due to how event processing is designed on</para>
        /// <para>those platforms.  You can use the</para>
        /// <para>[window refresh callback](</para>
        /// <para>your window when necessary during such operations.</para>
        /// <para>On some platforms, certain events are sent directly to the application</para>
        /// <para>without going through the event queue, causing callbacks to be called</para>
        /// <para>outside of a call to one of the event processing functions.</para>
        /// <para>Event processing is not required for joystick input to work.</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_PLATFORM_ERROR.</para>
        /// <para>This function must not be called from a callback.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>glfwWaitEvents</para>
        /// <para>glfwWaitEventsTimeout</para>
        /// <para>Added in version 1.0.</para>
        /// </remarks>
        public static void GlfwPollEvents()
        {
            __Internal.GlfwPollEvents();
        }

        /// <summary>Waits until events are queued and processes them.</summary>
        /// <remarks>
        /// <para>This function puts the calling thread to sleep until at least one event is</para>
        /// <para>available in the event queue.  Once one or more events are available,</para>
        /// <para>it behaves exactly like</para>
        /// <para>are processed and the function then returns immediately.  Processing events</para>
        /// <para>will cause the window and input callbacks associated with those events to be</para>
        /// <para>called.</para>
        /// <para>Since not all events are associated with callbacks, this function may return</para>
        /// <para>without a callback having been called even if you are monitoring all</para>
        /// <para>callbacks.</para>
        /// <para>On some platforms, a window move, resize or menu operation will cause event</para>
        /// <para>processing to block.  This is due to how event processing is designed on</para>
        /// <para>those platforms.  You can use the</para>
        /// <para>[window refresh callback](</para>
        /// <para>your window when necessary during such operations.</para>
        /// <para>On some platforms, certain callbacks may be called outside of a call to one</para>
        /// <para>of the event processing functions.</para>
        /// <para>If no windows exist, this function returns immediately.  For synchronization</para>
        /// <para>of threads in applications that do not create windows, use your threading</para>
        /// <para>library of choice.</para>
        /// <para>Event processing is not required for joystick input to work.</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_PLATFORM_ERROR.</para>
        /// <para>This function must not be called from a callback.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>glfwPollEvents</para>
        /// <para>glfwWaitEventsTimeout</para>
        /// <para>Added in version 2.5.</para>
        /// </remarks>
        public static void GlfwWaitEvents()
        {
            __Internal.GlfwWaitEvents();
        }

        /// <summary>Waits with timeout until events are queued and processes them.</summary>
        /// <param name="timeout">The maximum amount of time, in seconds, to wait.</param>
        /// <remarks>
        /// <para>This function puts the calling thread to sleep until at least one event is</para>
        /// <para>available in the event queue, or until the specified timeout is reached.  If</para>
        /// <para>one or more events are available, it behaves exactly like</para>
        /// <para>glfwPollEvents, i.e. the events in the queue are processed and the function</para>
        /// <para>then returns immediately.  Processing events will cause the window and input</para>
        /// <para>callbacks associated with those events to be called.</para>
        /// <para>The timeout value must be a positive finite number.</para>
        /// <para>Since not all events are associated with callbacks, this function may return</para>
        /// <para>without a callback having been called even if you are monitoring all</para>
        /// <para>callbacks.</para>
        /// <para>On some platforms, a window move, resize or menu operation will cause event</para>
        /// <para>processing to block.  This is due to how event processing is designed on</para>
        /// <para>those platforms.  You can use the</para>
        /// <para>[window refresh callback](</para>
        /// <para>your window when necessary during such operations.</para>
        /// <para>On some platforms, certain callbacks may be called outside of a call to one</para>
        /// <para>of the event processing functions.</para>
        /// <para>If no windows exist, this function returns immediately.  For synchronization</para>
        /// <para>of threads in applications that do not create windows, use your threading</para>
        /// <para>library of choice.</para>
        /// <para>Event processing is not required for joystick input to work.</para>
        /// <para>This function must not be called from a callback.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>glfwPollEvents</para>
        /// <para>glfwWaitEvents</para>
        /// <para>Added in version 3.2.</para>
        /// </remarks>
        public static void GlfwWaitEventsTimeout(double timeout)
        {
            __Internal.GlfwWaitEventsTimeout(timeout);
        }

        /// <summary>Posts an empty event to the event queue.</summary>
        /// <remarks>
        /// <para>This function posts an empty event from the current thread to the event</para>
        /// <para>queue, causing</para>
        /// <para>If no windows exist, this function returns immediately.  For synchronization</para>
        /// <para>of threads in applications that do not create windows, use your threading</para>
        /// <para>library of choice.</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_PLATFORM_ERROR.</para>
        /// <para>This function may be called from any thread.</para>
        /// <para>glfwWaitEvents</para>
        /// <para>glfwWaitEventsTimeout</para>
        /// <para>Added in version 3.1.</para>
        /// </remarks>
        public static void GlfwPostEmptyEvent()
        {
            __Internal.GlfwPostEmptyEvent();
        }

        /// <summary>Returns the value of an input option for the specified window.</summary>
        /// <param name="window">The window to query.</param>
        /// <param name="mode">
        /// <para>One of `GLFW_CURSOR`, `GLFW_STICKY_KEYS` or</para>
        /// <para>`GLFW_STICKY_MOUSE_BUTTONS`.</para>
        /// </param>
        /// <remarks>
        /// <para>This function returns the value of an input option for the specified window.</para>
        /// <para>The mode must be one of `GLFW_CURSOR`, `GLFW_STICKY_KEYS` or</para>
        /// <para>`GLFW_STICKY_MOUSE_BUTTONS`.</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_INVALID_ENUM.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>glfwSetInputMode</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static int GlfwGetInputMode(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow window, int mode)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GlfwGetInputMode(__arg0, mode);
            return __ret;
        }

        /// <summary>Sets an input option for the specified window.</summary>
        /// <param name="window">The window whose input mode to set.</param>
        /// <param name="mode">
        /// <para>One of `GLFW_CURSOR`, `GLFW_STICKY_KEYS` or</para>
        /// <para>`GLFW_STICKY_MOUSE_BUTTONS`.</para>
        /// </param>
        /// <param name="value">The new value of the specified input mode.</param>
        /// <remarks>
        /// <para>This function sets an input mode option for the specified window.  The mode</para>
        /// <para>must be one of `GLFW_CURSOR`, `GLFW_STICKY_KEYS` or</para>
        /// <para>`GLFW_STICKY_MOUSE_BUTTONS`.</para>
        /// <para>If the mode is `GLFW_CURSOR`, the value must be one of the following cursor</para>
        /// <para>modes:</para>
        /// <para>- `GLFW_CURSOR_NORMAL` makes the cursor visible and behaving normally.</para>
        /// <para>- `GLFW_CURSOR_HIDDEN` makes the cursor invisible when it is over the client</para>
        /// <para>area of the window but does not restrict the cursor from leaving.</para>
        /// <para>- `GLFW_CURSOR_DISABLED` hides and grabs the cursor, providing virtual</para>
        /// <para>and unlimited cursor movement.  This is useful for implementing for</para>
        /// <para>example 3D camera controls.</para>
        /// <para>If the mode is `GLFW_STICKY_KEYS`, the value must be either `GLFW_TRUE` to</para>
        /// <para>enable sticky keys, or `GLFW_FALSE` to disable it.  If sticky keys are</para>
        /// <para>enabled, a key press will ensure that</para>
        /// <para>the next time it is called even if the key had been released before the</para>
        /// <para>call.  This is useful when you are only interested in whether keys have been</para>
        /// <para>pressed but not when or in which order.</para>
        /// <para>If the mode is `GLFW_STICKY_MOUSE_BUTTONS`, the value must be either</para>
        /// <para>`GLFW_TRUE` to enable sticky mouse buttons, or `GLFW_FALSE` to disable it.</para>
        /// <para>If sticky mouse buttons are enabled, a mouse button press will ensure that</para>
        /// <para>if the mouse button had been released before the call.  This is useful when</para>
        /// <para>you are only interested in whether mouse buttons have been pressed but not</para>
        /// <para>when or in which order.</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_INVALID_ENUM and</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>glfwGetInputMode</para>
        /// <para>Added in version 3.0.  Replaces `glfwEnable` and `glfwDisable`.</para>
        /// </remarks>
        public static void GlfwSetInputMode(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow window, int mode, int value)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.GlfwSetInputMode(__arg0, mode, value);
        }

        /// <summary>Returns the localized name of the specified printable key.</summary>
        /// <param name="key">The key to query, or `GLFW_KEY_UNKNOWN`.</param>
        /// <param name="scancode">The scancode of the key to query.</param>
        /// <returns>
        /// <para>The localized name of the key, or `NULL`.</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_PLATFORM_ERROR.</para>
        /// <para>The returned string is allocated and freed by GLFW.  You</para>
        /// <para>should not free it yourself.  It is valid until the next call to</para>
        /// <para>glfwGetKeyName, or until the library is terminated.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns the localized name of the specified printable key.</para>
        /// <para>This is intended for displaying key bindings to the user.</para>
        /// <para>If the key is `GLFW_KEY_UNKNOWN`, the scancode is used instead, otherwise</para>
        /// <para>the scancode is ignored.  If a non-printable key or (if the key is</para>
        /// <para>`GLFW_KEY_UNKNOWN`) a scancode that maps to a non-printable key is</para>
        /// <para>specified, this function returns `NULL`.</para>
        /// <para>This behavior allows you to pass in the arguments passed to the</para>
        /// <para>[key callback](</para>
        /// <para>The printable keys are:</para>
        /// <para>- `GLFW_KEY_APOSTROPHE`</para>
        /// <para>- `GLFW_KEY_COMMA`</para>
        /// <para>- `GLFW_KEY_MINUS`</para>
        /// <para>- `GLFW_KEY_PERIOD`</para>
        /// <para>- `GLFW_KEY_SLASH`</para>
        /// <para>- `GLFW_KEY_SEMICOLON`</para>
        /// <para>- `GLFW_KEY_EQUAL`</para>
        /// <para>- `GLFW_KEY_LEFT_BRACKET`</para>
        /// <para>- `GLFW_KEY_RIGHT_BRACKET`</para>
        /// <para>- `GLFW_KEY_BACKSLASH`</para>
        /// <para>- `GLFW_KEY_WORLD_1`</para>
        /// <para>- `GLFW_KEY_WORLD_2`</para>
        /// <para>- `GLFW_KEY_0` to `GLFW_KEY_9`</para>
        /// <para>- `GLFW_KEY_A` to `GLFW_KEY_Z`</para>
        /// <para>- `GLFW_KEY_KP_0` to `GLFW_KEY_KP_9`</para>
        /// <para>- `GLFW_KEY_KP_DECIMAL`</para>
        /// <para>- `GLFW_KEY_KP_DIVIDE`</para>
        /// <para>- `GLFW_KEY_KP_MULTIPLY`</para>
        /// <para>- `GLFW_KEY_KP_SUBTRACT`</para>
        /// <para>- `GLFW_KEY_KP_ADD`</para>
        /// <para>- `GLFW_KEY_KP_EQUAL`</para>
        /// <para>Added in version 3.2.</para>
        /// </remarks>
        public static string GlfwGetKeyName(int key, int scancode)
        {
            var __ret = __Internal.GlfwGetKeyName(key, scancode);
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>
        /// <para>Returns the last reported state of a keyboard key for the specified</para>
        /// <para>window.</para>
        /// </summary>
        /// <param name="window">The desired window.</param>
        /// <param name="key">The desired [keyboard key](</param>
        /// <returns>
        /// <para>One of `GLFW_PRESS` or `GLFW_RELEASE`.</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_INVALID_ENUM.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns the last state reported for the specified key to the</para>
        /// <para>specified window.  The returned state is one of `GLFW_PRESS` or</para>
        /// <para>`GLFW_RELEASE`.  The higher-level action `GLFW_REPEAT` is only reported to</para>
        /// <para>the key callback.</para>
        /// <para>If the `GLFW_STICKY_KEYS` input mode is enabled, this function returns</para>
        /// <para>`GLFW_PRESS` the first time you call it for a key that was pressed, even if</para>
        /// <para>that key has already been released.</para>
        /// <para>The key functions deal with physical keys, with [key tokens](</para>
        /// <para>named after their use on the standard US keyboard layout.  If you want to</para>
        /// <para>input text, use the Unicode character callback instead.</para>
        /// <para>The [modifier key bit masks](</para>
        /// <para>used with this function.</para>
        /// <para>__Do not use this function__ to implement [text input](</para>
        /// <para>not a valid key for this function.</para>
        /// <para>Added in version 1.0.</para>
        /// <para>Added window handle parameter.</para>
        /// </remarks>
        public static int GlfwGetKey(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow window, int key)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GlfwGetKey(__arg0, key);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the last reported state of a mouse button for the specified</para>
        /// <para>window.</para>
        /// </summary>
        /// <param name="window">The desired window.</param>
        /// <param name="button">The desired [mouse button](</param>
        /// <returns>
        /// <para>One of `GLFW_PRESS` or `GLFW_RELEASE`.</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_INVALID_ENUM.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns the last state reported for the specified mouse button</para>
        /// <para>to the specified window.  The returned state is one of `GLFW_PRESS` or</para>
        /// <para>`GLFW_RELEASE`.</para>
        /// <para>If the `GLFW_STICKY_MOUSE_BUTTONS` input mode is enabled, this function</para>
        /// <para>`GLFW_PRESS` the first time you call it for a mouse button that was pressed,</para>
        /// <para>even if that mouse button has already been released.</para>
        /// <para>Added in version 1.0.</para>
        /// <para>Added window handle parameter.</para>
        /// </remarks>
        public static int GlfwGetMouseButton(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow window, int button)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GlfwGetMouseButton(__arg0, button);
            return __ret;
        }

        /// <summary>
        /// <para>Retrieves the position of the cursor relative to the client area of</para>
        /// <para>the window.</para>
        /// </summary>
        /// <param name="window">The desired window.</param>
        /// <param name="xpos">
        /// <para>Where to store the cursor x-coordinate, relative to the</para>
        /// <para>left edge of the client area, or `NULL`.</para>
        /// </param>
        /// <param name="ypos">
        /// <para>Where to store the cursor y-coordinate, relative to the to</para>
        /// <para>top edge of the client area, or `NULL`.</para>
        /// </param>
        /// <remarks>
        /// <para>This function returns the position of the cursor, in screen coordinates,</para>
        /// <para>relative to the upper-left corner of the client area of the specified</para>
        /// <para>window.</para>
        /// <para>If the cursor is disabled (with `GLFW_CURSOR_DISABLED`) then the cursor</para>
        /// <para>position is unbounded and limited only by the minimum and maximum values of</para>
        /// <para>a `double`.</para>
        /// <para>The coordinate can be converted to their integer equivalents with the</para>
        /// <para>`floor` function.  Casting directly to an integer type works for positive</para>
        /// <para>coordinates, but fails for negative ones.</para>
        /// <para>Any or all of the position arguments may be `NULL`.  If an error occurs, all</para>
        /// <para>non-`NULL` position arguments will be set to zero.</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_PLATFORM_ERROR.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>glfwSetCursorPos</para>
        /// <para>Added in version 3.0.  Replaces `glfwGetMousePos`.</para>
        /// </remarks>
        public static void GlfwGetCursorPos(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow window, ref double xpos, ref double ypos)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            fixed (double* __refParamPtr1 = &xpos)
            {
                var __arg1 = __refParamPtr1;
                fixed (double* __refParamPtr2 = &ypos)
                {
                    var __arg2 = __refParamPtr2;
                    __Internal.GlfwGetCursorPos(__arg0, __arg1, __arg2);
                }
            }
        }

        /// <summary>
        /// <para>Sets the position of the cursor, relative to the client area of the</para>
        /// <para>window.</para>
        /// </summary>
        /// <param name="window">The desired window.</param>
        /// <param name="xpos">
        /// <para>The desired x-coordinate, relative to the left edge of the</para>
        /// <para>client area.</para>
        /// </param>
        /// <param name="ypos">
        /// <para>The desired y-coordinate, relative to the top edge of the</para>
        /// <para>client area.</para>
        /// </param>
        /// <remarks>
        /// <para>This function sets the position, in screen coordinates, of the cursor</para>
        /// <para>relative to the upper-left corner of the client area of the specified</para>
        /// <para>window.  The window must have input focus.  If the window does not have</para>
        /// <para>input focus when this function is called, it fails silently.</para>
        /// <para>__Do not use this function__ to implement things like camera controls.  GLFW</para>
        /// <para>already provides the `GLFW_CURSOR_DISABLED` cursor mode that hides the</para>
        /// <para>cursor, transparently re-centers it and provides unconstrained cursor</para>
        /// <para>motion.  See</para>
        /// <para>If the cursor mode is `GLFW_CURSOR_DISABLED` then the cursor position is</para>
        /// <para>unconstrained and limited only by the minimum and maximum values of</para>
        /// <para>a `double`.</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_PLATFORM_ERROR.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>glfwGetCursorPos</para>
        /// <para>Added in version 3.0.  Replaces `glfwSetMousePos`.</para>
        /// </remarks>
        public static void GlfwSetCursorPos(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow window, double xpos, double ypos)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.GlfwSetCursorPos(__arg0, xpos, ypos);
        }

        /// <summary>Creates a custom cursor.</summary>
        /// <param name="image">The desired cursor image.</param>
        /// <param name="xhot">The desired x-coordinate, in pixels, of the cursor hotspot.</param>
        /// <param name="yhot">The desired y-coordinate, in pixels, of the cursor hotspot.</param>
        /// <returns>
        /// <para>The handle of the created cursor, or `NULL` if an</para>
        /// <para>[error](</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_PLATFORM_ERROR.</para>
        /// <para>The specified image data is copied before this function</para>
        /// <para>returns.</para>
        /// <para>This function must not be called from a callback.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>Creates a new custom cursor image that can be set for a window with</para>
        /// <para>glfwSetCursor.  The cursor can be destroyed with</para>
        /// <para>Any remaining cursors are destroyed by</para>
        /// <para>The pixels are 32-bit, little-endian, non-premultiplied RGBA, i.e. eight</para>
        /// <para>bits per channel.  They are arranged canonically as packed sequential rows,</para>
        /// <para>starting from the top-left corner.</para>
        /// <para>The cursor hotspot is specified in pixels, relative to the upper-left corner</para>
        /// <para>of the cursor image.  Like all other coordinate systems in GLFW, the X-axis</para>
        /// <para>points to the right and the Y-axis points down.</para>
        /// <para>glfwDestroyCursor</para>
        /// <para>glfwCreateStandardCursor</para>
        /// <para>Added in version 3.1.</para>
        /// </remarks>
        public static global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWcursor GlfwCreateCursor(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWimage image, int xhot, int yhot)
        {
            var __arg0 = ReferenceEquals(image, null) ? global::System.IntPtr.Zero : image.__Instance;
            var __ret = __Internal.GlfwCreateCursor(__arg0, xhot, yhot);
            global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWcursor __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWcursor.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWcursor) global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWcursor.NativeToManagedMap[__ret];
            else __result0 = global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWcursor.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Creates a cursor with a standard shape.</summary>
        /// <param name="shape">One of the [standard shapes](</param>
        /// <returns>
        /// <para>A new cursor ready to use or `NULL` if an</para>
        /// <para>[error](</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_INVALID_ENUM and</para>
        /// <para>This function must not be called from a callback.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>Returns a cursor with a [standard shape](</para>
        /// <para>a window with</para>
        /// <para>glfwCreateCursor</para>
        /// <para>Added in version 3.1.</para>
        /// </remarks>
        public static global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWcursor GlfwCreateStandardCursor(int shape)
        {
            var __ret = __Internal.GlfwCreateStandardCursor(shape);
            global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWcursor __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWcursor.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWcursor) global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWcursor.NativeToManagedMap[__ret];
            else __result0 = global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWcursor.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Destroys a cursor.</summary>
        /// <param name="cursor">The cursor object to destroy.</param>
        /// <remarks>
        /// <para>This function destroys a cursor previously created with</para>
        /// <para>glfwCreateCursor.  Any remaining cursors will be destroyed by</para>
        /// <para>glfwTerminate.</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_PLATFORM_ERROR.</para>
        /// <para>This function must not be called from a callback.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>glfwCreateCursor</para>
        /// <para>Added in version 3.1.</para>
        /// </remarks>
        public static void GlfwDestroyCursor(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWcursor cursor)
        {
            var __arg0 = ReferenceEquals(cursor, null) ? global::System.IntPtr.Zero : cursor.__Instance;
            __Internal.GlfwDestroyCursor(__arg0);
        }

        /// <summary>Sets the cursor for the window.</summary>
        /// <param name="window">The window to set the cursor for.</param>
        /// <param name="cursor">
        /// <para>The cursor to set, or `NULL` to switch back to the default</para>
        /// <para>arrow cursor.</para>
        /// </param>
        /// <remarks>
        /// <para>This function sets the cursor image to be used when the cursor is over the</para>
        /// <para>client area of the specified window.  The set cursor will only be visible</para>
        /// <para>when the [cursor mode](</para>
        /// <para>`GLFW_CURSOR_NORMAL`.</para>
        /// <para>On some platforms, the set cursor may not be visible unless the window also</para>
        /// <para>has input focus.</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_PLATFORM_ERROR.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 3.1.</para>
        /// </remarks>
        public static void GlfwSetCursor(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow window, global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWcursor cursor)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = ReferenceEquals(cursor, null) ? global::System.IntPtr.Zero : cursor.__Instance;
            __Internal.GlfwSetCursor(__arg0, __arg1);
        }

        /// <summary>Sets the key callback.</summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="cbfun">
        /// <para>The new key callback, or `NULL` to remove the currently</para>
        /// <para>set callback.</para>
        /// </param>
        /// <returns>
        /// <para>The previously set callback, or `NULL` if no callback was set or the</para>
        /// <para>library had not been [initialized](</para>
        /// <para>Possible errors include</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function sets the key callback of the specified window, which is called</para>
        /// <para>when a key is pressed, repeated or released.</para>
        /// <para>The key functions deal with physical keys, with layout independent</para>
        /// <para>[key tokens](</para>
        /// <para>layout.  If you want to input text, use the</para>
        /// <para>[character callback](</para>
        /// <para>When a window loses input focus, it will generate synthetic key release</para>
        /// <para>events for all pressed keys.  You can tell these events from user-generated</para>
        /// <para>events by the fact that the synthetic ones are generated after the focus</para>
        /// <para>loss event has been processed, i.e. after the</para>
        /// <para>[window focus callback](</para>
        /// <para>The scancode of a key is specific to that platform or sometimes even to that</para>
        /// <para>machine.  Scancodes are intended to allow users to bind keys that don't have</para>
        /// <para>a GLFW key token.  Such keys have `key` set to `GLFW_KEY_UNKNOWN`, their</para>
        /// <para>state is not saved and so it cannot be queried with</para>
        /// <para>Sometimes GLFW needs to generate synthetic key events, in which case the</para>
        /// <para>scancode may be zero.</para>
        /// <para>Added in version 1.0.</para>
        /// <para>Added window handle parameter and return value.</para>
        /// </remarks>
        public static global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWkeyfun GlfwSetKeyCallback(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow window, global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWkeyfun cbfun)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.GlfwSetKeyCallback(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWkeyfun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWkeyfun));
        }

        /// <summary>Sets the Unicode character callback.</summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="cbfun">
        /// <para>The new callback, or `NULL` to remove the currently set</para>
        /// <para>callback.</para>
        /// </param>
        /// <returns>
        /// <para>The previously set callback, or `NULL` if no callback was set or the</para>
        /// <para>library had not been [initialized](</para>
        /// <para>Possible errors include</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function sets the character callback of the specified window, which is</para>
        /// <para>called when a Unicode character is input.</para>
        /// <para>The character callback is intended for Unicode text input.  As it deals with</para>
        /// <para>characters, it is keyboard layout dependent, whereas the</para>
        /// <para>[key callback](</para>
        /// <para>to physical keys, as a key may produce zero, one or more characters.  If you</para>
        /// <para>want to know whether a specific physical key was pressed or released, see</para>
        /// <para>the key callback instead.</para>
        /// <para>The character callback behaves as system text input normally does and will</para>
        /// <para>not be called if modifier keys are held down that would prevent normal text</para>
        /// <para>input on that platform, for example a Super (Command) key on OS X or Alt key</para>
        /// <para>on Windows.  There is a</para>
        /// <para>[character with modifiers callback](</para>
        /// <para>receives these events.</para>
        /// <para>Added in version 2.4.</para>
        /// <para>Added window handle parameter and return value.</para>
        /// </remarks>
        public static global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWcharfun GlfwSetCharCallback(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow window, global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWcharfun cbfun)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.GlfwSetCharCallback(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWcharfun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWcharfun));
        }

        /// <summary>Sets the Unicode character with modifiers callback.</summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="cbfun">
        /// <para>The new callback, or `NULL` to remove the currently set</para>
        /// <para>callback.</para>
        /// </param>
        /// <returns>
        /// <para>The previously set callback, or `NULL` if no callback was set or an</para>
        /// <para>[error](</para>
        /// <para>Possible errors include</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function sets the character with modifiers callback of the specified</para>
        /// <para>window, which is called when a Unicode character is input regardless of what</para>
        /// <para>modifier keys are used.</para>
        /// <para>The character with modifiers callback is intended for implementing custom</para>
        /// <para>Unicode character input.  For regular Unicode text input, see the</para>
        /// <para>[character callback](</para>
        /// <para>callback, the character with modifiers callback deals with characters and is</para>
        /// <para>keyboard layout dependent.  Characters do not map 1:1 to physical keys, as</para>
        /// <para>a key may produce zero, one or more characters.  If you want to know whether</para>
        /// <para>a specific physical key was pressed or released, see the</para>
        /// <para>[key callback](</para>
        /// <para>Added in version 3.1.</para>
        /// </remarks>
        public static global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWcharmodsfun GlfwSetCharModsCallback(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow window, global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWcharmodsfun cbfun)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.GlfwSetCharModsCallback(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWcharmodsfun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWcharmodsfun));
        }

        /// <summary>Sets the mouse button callback.</summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="cbfun">
        /// <para>The new callback, or `NULL` to remove the currently set</para>
        /// <para>callback.</para>
        /// </param>
        /// <returns>
        /// <para>The previously set callback, or `NULL` if no callback was set or the</para>
        /// <para>library had not been [initialized](</para>
        /// <para>Possible errors include</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function sets the mouse button callback of the specified window, which</para>
        /// <para>is called when a mouse button is pressed or released.</para>
        /// <para>When a window loses input focus, it will generate synthetic mouse button</para>
        /// <para>release events for all pressed mouse buttons.  You can tell these events</para>
        /// <para>from user-generated events by the fact that the synthetic ones are generated</para>
        /// <para>after the focus loss event has been processed, i.e. after the</para>
        /// <para>[window focus callback](</para>
        /// <para>Added in version 1.0.</para>
        /// <para>Added window handle parameter and return value.</para>
        /// </remarks>
        public static global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWmousebuttonfun GlfwSetMouseButtonCallback(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow window, global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWmousebuttonfun cbfun)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.GlfwSetMouseButtonCallback(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWmousebuttonfun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWmousebuttonfun));
        }

        /// <summary>Sets the cursor position callback.</summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="cbfun">
        /// <para>The new callback, or `NULL` to remove the currently set</para>
        /// <para>callback.</para>
        /// </param>
        /// <returns>
        /// <para>The previously set callback, or `NULL` if no callback was set or the</para>
        /// <para>library had not been [initialized](</para>
        /// <para>Possible errors include</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function sets the cursor position callback of the specified window,</para>
        /// <para>which is called when the cursor is moved.  The callback is provided with the</para>
        /// <para>position, in screen coordinates, relative to the upper-left corner of the</para>
        /// <para>client area of the window.</para>
        /// <para>Added in version 3.0.  Replaces `glfwSetMousePosCallback`.</para>
        /// </remarks>
        public static global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWcursorposfun GlfwSetCursorPosCallback(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow window, global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWcursorposfun cbfun)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.GlfwSetCursorPosCallback(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWcursorposfun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWcursorposfun));
        }

        /// <summary>Sets the cursor enter/exit callback.</summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="cbfun">
        /// <para>The new callback, or `NULL` to remove the currently set</para>
        /// <para>callback.</para>
        /// </param>
        /// <returns>
        /// <para>The previously set callback, or `NULL` if no callback was set or the</para>
        /// <para>library had not been [initialized](</para>
        /// <para>Possible errors include</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function sets the cursor boundary crossing callback of the specified</para>
        /// <para>window, which is called when the cursor enters or leaves the client area of</para>
        /// <para>the window.</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWcursorenterfun GlfwSetCursorEnterCallback(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow window, global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWcursorenterfun cbfun)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.GlfwSetCursorEnterCallback(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWcursorenterfun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWcursorenterfun));
        }

        /// <summary>Sets the scroll callback.</summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="cbfun">
        /// <para>The new scroll callback, or `NULL` to remove the currently</para>
        /// <para>set callback.</para>
        /// </param>
        /// <returns>
        /// <para>The previously set callback, or `NULL` if no callback was set or the</para>
        /// <para>library had not been [initialized](</para>
        /// <para>Possible errors include</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function sets the scroll callback of the specified window, which is</para>
        /// <para>called when a scrolling device is used, such as a mouse wheel or scrolling</para>
        /// <para>area of a touchpad.</para>
        /// <para>The scroll callback receives all scrolling input, like that from a mouse</para>
        /// <para>wheel or a touchpad scrolling area.</para>
        /// <para>Added in version 3.0.  Replaces `glfwSetMouseWheelCallback`.</para>
        /// </remarks>
        public static global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWscrollfun GlfwSetScrollCallback(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow window, global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWscrollfun cbfun)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.GlfwSetScrollCallback(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWscrollfun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWscrollfun));
        }

        /// <summary>Sets the file drop callback.</summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="cbfun">
        /// <para>The new file drop callback, or `NULL` to remove the</para>
        /// <para>currently set callback.</para>
        /// </param>
        /// <returns>
        /// <para>The previously set callback, or `NULL` if no callback was set or the</para>
        /// <para>library had not been [initialized](</para>
        /// <para>Possible errors include</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function sets the file drop callback of the specified window, which is</para>
        /// <para>called when one or more dragged files are dropped on the window.</para>
        /// <para>Because the path array and its strings may have been generated specifically</para>
        /// <para>for that event, they are not guaranteed to be valid after the callback has</para>
        /// <para>returned.  If you wish to use them after the callback returns, you need to</para>
        /// <para>make a deep copy.</para>
        /// <para>Added in version 3.1.</para>
        /// </remarks>
        public static global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWdropfun GlfwSetDropCallback(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow window, global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWdropfun cbfun)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.GlfwSetDropCallback(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWdropfun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWdropfun));
        }

        /// <summary>Returns whether the specified joystick is present.</summary>
        /// <param name="joy">The [joystick](</param>
        /// <returns>
        /// <para>`GLFW_TRUE` if the joystick is present, or `GLFW_FALSE` otherwise.</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_INVALID_ENUM and</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns whether the specified joystick is present.</para>
        /// <para>Added in version 3.0.  Replaces `glfwGetJoystickParam`.</para>
        /// </remarks>
        public static int GlfwJoystickPresent(int joy)
        {
            var __ret = __Internal.GlfwJoystickPresent(joy);
            return __ret;
        }

        /// <summary>Returns the values of all axes of the specified joystick.</summary>
        /// <param name="joy">The [joystick](</param>
        /// <param name="count">
        /// <para>Where to store the number of axis values in the returned</para>
        /// <para>array.  This is set to zero if the joystick is not present or an error</para>
        /// <para>occurred.</para>
        /// </param>
        /// <returns>
        /// <para>An array of axis values, or `NULL` if the joystick is not present or</para>
        /// <para>an [error](</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_INVALID_ENUM and</para>
        /// <para>The returned array is allocated and freed by GLFW.  You</para>
        /// <para>should not free it yourself.  It is valid until the specified joystick is</para>
        /// <para>disconnected, this function is called again for that joystick or the library</para>
        /// <para>is terminated.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns the values of all axes of the specified joystick.</para>
        /// <para>Each element in the array is a value between -1.0 and 1.0.</para>
        /// <para>Querying a joystick slot with no device present is not an error, but will</para>
        /// <para>cause this function to return `NULL`.  Call</para>
        /// <para>check device presence.</para>
        /// <para>Added in version 3.0.  Replaces `glfwGetJoystickPos`.</para>
        /// </remarks>
        public static float* GlfwGetJoystickAxes(int joy, ref int count)
        {
            fixed (int* __refParamPtr1 = &count)
            {
                var __arg1 = __refParamPtr1;
                var __ret = __Internal.GlfwGetJoystickAxes(joy, __arg1);
                return __ret;
            }
        }

        /// <summary>Returns the state of all buttons of the specified joystick.</summary>
        /// <param name="joy">The [joystick](</param>
        /// <param name="count">
        /// <para>Where to store the number of button states in the returned</para>
        /// <para>array.  This is set to zero if the joystick is not present or an error</para>
        /// <para>occurred.</para>
        /// </param>
        /// <returns>
        /// <para>An array of button states, or `NULL` if the joystick is not present</para>
        /// <para>or an [error](</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_INVALID_ENUM and</para>
        /// <para>The returned array is allocated and freed by GLFW.  You</para>
        /// <para>should not free it yourself.  It is valid until the specified joystick is</para>
        /// <para>disconnected, this function is called again for that joystick or the library</para>
        /// <para>is terminated.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns the state of all buttons of the specified joystick.</para>
        /// <para>Each element in the array is either `GLFW_PRESS` or `GLFW_RELEASE`.</para>
        /// <para>Querying a joystick slot with no device present is not an error, but will</para>
        /// <para>cause this function to return `NULL`.  Call</para>
        /// <para>check device presence.</para>
        /// <para>Added in version 2.2.</para>
        /// <para>Changed to return a dynamic array.</para>
        /// </remarks>
        public static byte* GlfwGetJoystickButtons(int joy, ref int count)
        {
            fixed (int* __refParamPtr1 = &count)
            {
                var __arg1 = __refParamPtr1;
                var __ret = __Internal.GlfwGetJoystickButtons(joy, __arg1);
                return __ret;
            }
        }

        /// <summary>Returns the name of the specified joystick.</summary>
        /// <param name="joy">The [joystick](</param>
        /// <returns>
        /// <para>The UTF-8 encoded name of the joystick, or `NULL` if the joystick</para>
        /// <para>is not present or an [error](</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_INVALID_ENUM and</para>
        /// <para>The returned string is allocated and freed by GLFW.  You</para>
        /// <para>should not free it yourself.  It is valid until the specified joystick is</para>
        /// <para>disconnected, this function is called again for that joystick or the library</para>
        /// <para>is terminated.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns the name, encoded as UTF-8, of the specified joystick.</para>
        /// <para>The returned string is allocated and freed by GLFW.  You should not free it</para>
        /// <para>yourself.</para>
        /// <para>Querying a joystick slot with no device present is not an error, but will</para>
        /// <para>cause this function to return `NULL`.  Call</para>
        /// <para>check device presence.</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static string GlfwGetJoystickName(int joy)
        {
            var __ret = __Internal.GlfwGetJoystickName(joy);
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>Sets the joystick configuration callback.</summary>
        /// <param name="cbfun">
        /// <para>The new callback, or `NULL` to remove the currently set</para>
        /// <para>callback.</para>
        /// </param>
        /// <returns>
        /// <para>The previously set callback, or `NULL` if no callback was set or the</para>
        /// <para>library had not been [initialized](</para>
        /// <para>Possible errors include</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function sets the joystick configuration callback, or removes the</para>
        /// <para>currently set callback.  This is called when a joystick is connected to or</para>
        /// <para>disconnected from the system.</para>
        /// <para>Added in version 3.2.</para>
        /// </remarks>
        public static global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWjoystickfun GlfwSetJoystickCallback(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWjoystickfun cbfun)
        {
            var __arg0 = cbfun == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var __ret = __Internal.GlfwSetJoystickCallback(__arg0);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWjoystickfun)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWjoystickfun));
        }

        /// <summary>Sets the clipboard to the specified string.</summary>
        /// <param name="window">The window that will own the clipboard contents.</param>
        /// <param name="string">A UTF-8 encoded string.</param>
        /// <remarks>
        /// <para>This function sets the system clipboard to the specified, UTF-8 encoded</para>
        /// <para>string.</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_PLATFORM_ERROR.</para>
        /// <para>The specified string is copied before this function</para>
        /// <para>returns.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>glfwGetClipboardString</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static void GlfwSetClipboardString(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow window, string @string)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.GlfwSetClipboardString(__arg0, @string);
        }

        /// <summary>Returns the contents of the clipboard as a string.</summary>
        /// <param name="window">The window that will request the clipboard contents.</param>
        /// <returns>
        /// <para>The contents of the clipboard as a UTF-8 encoded string, or `NULL`</para>
        /// <para>if an [error](</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_PLATFORM_ERROR.</para>
        /// <para>The returned string is allocated and freed by GLFW.  You</para>
        /// <para>should not free it yourself.  It is valid until the next call to</para>
        /// <para>glfwGetClipboardString or</para>
        /// <para>is terminated.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns the contents of the system clipboard, if it contains</para>
        /// <para>or is convertible to a UTF-8 encoded string.  If the clipboard is empty or</para>
        /// <para>if its contents cannot be converted, `NULL` is returned and a</para>
        /// <para>GLFW_FORMAT_UNAVAILABLE error is generated.</para>
        /// <para>glfwSetClipboardString</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static string GlfwGetClipboardString(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GlfwGetClipboardString(__arg0);
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>Returns the value of the GLFW timer.</summary>
        /// <returns>
        /// <para>The current value, in seconds, or zero if an</para>
        /// <para>[error](</para>
        /// <para>Possible errors include</para>
        /// <para>This function may be called from any thread.  Reading and</para>
        /// <para>writing of the internal timer offset is not atomic, so it needs to be</para>
        /// <para>externally synchronized with calls to</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns the value of the GLFW timer.  Unless the timer has</para>
        /// <para>been set using</para>
        /// <para>was initialized.</para>
        /// <para>The resolution of the timer is system dependent, but is usually on the order</para>
        /// <para>of a few micro- or nanoseconds.  It uses the highest-resolution monotonic</para>
        /// <para>time source on each supported platform.</para>
        /// <para>Added in version 1.0.</para>
        /// </remarks>
        public static double GlfwGetTime()
        {
            var __ret = __Internal.GlfwGetTime();
            return __ret;
        }

        /// <summary>Sets the GLFW timer.</summary>
        /// <param name="time">The new value, in seconds.</param>
        /// <remarks>
        /// <para>This function sets the value of the GLFW timer.  It then continues to count</para>
        /// <para>up from that value.  The value must be a positive finite number less than</para>
        /// <para>or equal to 18446744073.0, which is approximately 584.5 years.</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_INVALID_VALUE.</para>
        /// <para>The upper limit of the timer is calculated as</para>
        /// <para>floor((264- 1) / 109) and is due to implementations</para>
        /// <para>storing nanoseconds in 64 bits.  The limit may be increased in the future.</para>
        /// <para>This function may be called from any thread.  Reading and</para>
        /// <para>writing of the internal timer offset is not atomic, so it needs to be</para>
        /// <para>externally synchronized with calls to</para>
        /// <para>Added in version 2.2.</para>
        /// </remarks>
        public static void GlfwSetTime(double time)
        {
            __Internal.GlfwSetTime(time);
        }

        /// <summary>Returns the current value of the raw timer.</summary>
        /// <returns>
        /// <para>The value of the timer, or zero if an</para>
        /// <para>[error](</para>
        /// <para>Possible errors include</para>
        /// <para>This function may be called from any thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns the current value of the raw timer, measured in</para>
        /// <para>1&#160;/&#160;frequency seconds.  To get the frequency, call</para>
        /// <para>glfwGetTimerFrequency.</para>
        /// <para>glfwGetTimerFrequency</para>
        /// <para>Added in version 3.2.</para>
        /// </remarks>
        public static ulong GlfwGetTimerValue()
        {
            var __ret = __Internal.GlfwGetTimerValue();
            return __ret;
        }

        /// <summary>Returns the frequency, in Hz, of the raw timer.</summary>
        /// <returns>
        /// <para>The frequency of the timer, in Hz, or zero if an</para>
        /// <para>[error](</para>
        /// <para>Possible errors include</para>
        /// <para>This function may be called from any thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns the frequency, in Hz, of the raw timer.</para>
        /// <para>glfwGetTimerValue</para>
        /// <para>Added in version 3.2.</para>
        /// </remarks>
        public static ulong GlfwGetTimerFrequency()
        {
            var __ret = __Internal.GlfwGetTimerFrequency();
            return __ret;
        }

        /// <summary>
        /// <para>Makes the context of the specified window current for the calling</para>
        /// <para>thread.</para>
        /// </summary>
        /// <param name="window">
        /// <para>The window whose context to make current, or `NULL` to</para>
        /// <para>detach the current context.</para>
        /// </param>
        /// <remarks>
        /// <para>This function makes the OpenGL or OpenGL ES context of the specified window</para>
        /// <para>current on the calling thread.  A context can only be made current on</para>
        /// <para>a single thread at a time and each thread can have only a single current</para>
        /// <para>context at a time.</para>
        /// <para>By default, making a context non-current implicitly forces a pipeline flush.</para>
        /// <para>On machines that support `GL_KHR_context_flush_control`, you can control</para>
        /// <para>whether a context performs this flush by setting the</para>
        /// <para>[GLFW_CONTEXT_RELEASE_BEHAVIOR](</para>
        /// <para>The specified window must have an OpenGL or OpenGL ES context.  Specifying</para>
        /// <para>a window without a context will generate a</para>
        /// <para>error.</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_NO_WINDOW_CONTEXT and</para>
        /// <para>This function may be called from any thread.</para>
        /// <para>glfwGetCurrentContext</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static void GlfwMakeContextCurrent(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.GlfwMakeContextCurrent(__arg0);
        }

        /// <summary>Returns the window whose context is current on the calling thread.</summary>
        /// <returns>
        /// <para>The window whose context is current, or `NULL` if no window's</para>
        /// <para>context is current.</para>
        /// <para>Possible errors include</para>
        /// <para>This function may be called from any thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns the window whose OpenGL or OpenGL ES context is</para>
        /// <para>current on the calling thread.</para>
        /// <para>glfwMakeContextCurrent</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow GlfwGetCurrentContext()
        {
            var __ret = __Internal.GlfwGetCurrentContext();
            global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow) global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow.NativeToManagedMap[__ret];
            else __result0 = global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Swaps the front and back buffers of the specified window.</summary>
        /// <param name="window">The window whose buffers to swap.</param>
        /// <remarks>
        /// <para>This function swaps the front and back buffers of the specified window when</para>
        /// <para>rendering with OpenGL or OpenGL ES.  If the swap interval is greater than</para>
        /// <para>zero, the GPU driver waits the specified number of screen updates before</para>
        /// <para>swapping the buffers.</para>
        /// <para>The specified window must have an OpenGL or OpenGL ES context.  Specifying</para>
        /// <para>a window without a context will generate a</para>
        /// <para>error.</para>
        /// <para>This function does not apply to Vulkan.  If you are rendering with Vulkan,</para>
        /// <para>see `vkQueuePresentKHR` instead.</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_NO_WINDOW_CONTEXT and</para>
        /// <para>__EGL:__ The context of the specified window must be current on the</para>
        /// <para>calling thread.</para>
        /// <para>This function may be called from any thread.</para>
        /// <para>glfwSwapInterval</para>
        /// <para>Added in version 1.0.</para>
        /// <para>Added window handle parameter.</para>
        /// </remarks>
        public static void GlfwSwapBuffers(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWwindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.GlfwSwapBuffers(__arg0);
        }

        /// <summary>Sets the swap interval for the current context.</summary>
        /// <param name="interval">
        /// <para>The minimum number of screen updates to wait for</para>
        /// <para>until the buffers are swapped by</para>
        /// </param>
        /// <remarks>
        /// <para>This function sets the swap interval for the current OpenGL or OpenGL ES</para>
        /// <para>context, i.e. the number of screen updates to wait from the time</para>
        /// <para>glfwSwapBuffers was called before swapping the buffers and returning.  This</para>
        /// <para>is sometimes called _vertical synchronization_, _vertical retrace</para>
        /// <para>synchronization_ or just _vsync_.</para>
        /// <para>Contexts that support either of the `WGL_EXT_swap_control_tear` and</para>
        /// <para>`GLX_EXT_swap_control_tear` extensions also accept negative swap intervals,</para>
        /// <para>which allow the driver to swap even if a frame arrives a little bit late.</para>
        /// <para>You can check for the presence of these extensions using</para>
        /// <para>glfwExtensionSupported.  For more information about swap tearing, see the</para>
        /// <para>extension specifications.</para>
        /// <para>A context must be current on the calling thread.  Calling this function</para>
        /// <para>without a current context will cause a</para>
        /// <para>This function does not apply to Vulkan.  If you are rendering with Vulkan,</para>
        /// <para>see the present mode of your swapchain instead.</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_NO_CURRENT_CONTEXT and</para>
        /// <para>This function is not called during context creation, leaving the</para>
        /// <para>swap interval set to whatever is the default on that platform.  This is done</para>
        /// <para>because some swap interval extensions used by GLFW do not allow the swap</para>
        /// <para>interval to be reset to zero once it has been set to a non-zero value.</para>
        /// <para>Some GPU drivers do not honor the requested swap interval, either</para>
        /// <para>because of a user setting that overrides the application's request or due to</para>
        /// <para>bugs in the driver.</para>
        /// <para>This function may be called from any thread.</para>
        /// <para>glfwSwapBuffers</para>
        /// <para>Added in version 1.0.</para>
        /// </remarks>
        public static void GlfwSwapInterval(int interval)
        {
            __Internal.GlfwSwapInterval(interval);
        }

        /// <summary>Returns whether the specified extension is available.</summary>
        /// <param name="extension">The ASCII encoded name of the extension.</param>
        /// <returns>
        /// <para>`GLFW_TRUE` if the extension is available, or `GLFW_FALSE`</para>
        /// <para>otherwise.</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_NO_CURRENT_CONTEXT,</para>
        /// <para>GLFW_PLATFORM_ERROR.</para>
        /// <para>This function may be called from any thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns whether the specified</para>
        /// <para>[API extension](</para>
        /// <para>OpenGL ES context.  It searches both for client API extension and context</para>
        /// <para>creation API extensions.</para>
        /// <para>A context must be current on the calling thread.  Calling this function</para>
        /// <para>without a current context will cause a</para>
        /// <para>As this functions retrieves and searches one or more extension strings each</para>
        /// <para>call, it is recommended that you cache its results if it is going to be used</para>
        /// <para>frequently.  The extension strings will not change during the lifetime of</para>
        /// <para>a context, so there is no danger in doing this.</para>
        /// <para>This function does not apply to Vulkan.  If you are using Vulkan, see</para>
        /// <para>glfwGetRequiredInstanceExtensions, `vkEnumerateInstanceExtensionProperties`</para>
        /// <para>and `vkEnumerateDeviceExtensionProperties` instead.</para>
        /// <para>glfwGetProcAddress</para>
        /// <para>Added in version 1.0.</para>
        /// </remarks>
        public static int GlfwExtensionSupported(string extension)
        {
            var __ret = __Internal.GlfwExtensionSupported(extension);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the address of the specified function for the current</para>
        /// <para>context.</para>
        /// </summary>
        /// <param name="procname">The ASCII encoded name of the function.</param>
        /// <returns>
        /// <para>The address of the function, or `NULL` if an</para>
        /// <para>[error](</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_NO_CURRENT_CONTEXT and</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns the address of the specified OpenGL or OpenGL ES</para>
        /// <para>[core or extension function](</para>
        /// <para>by the current context.</para>
        /// <para>A context must be current on the calling thread.  Calling this function</para>
        /// <para>without a current context will cause a</para>
        /// <para>This function does not apply to Vulkan.  If you are rendering with Vulkan,</para>
        /// <para>see</para>
        /// <para>`vkGetDeviceProcAddr` instead.</para>
        /// <para>The address of a given function is not guaranteed to be the same</para>
        /// <para>between contexts.</para>
        /// <para>This function may return a non-`NULL` address despite the</para>
        /// <para>associated version or extension not being available.  Always check the</para>
        /// <para>context version or extension string first.</para>
        /// <para>The returned function pointer is valid until the context</para>
        /// <para>is destroyed or the library is terminated.</para>
        /// <para>This function may be called from any thread.</para>
        /// <para>glfwExtensionSupported</para>
        /// <para>Added in version 1.0.</para>
        /// </remarks>
        public static global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWglproc GlfwGetProcAddress(string procname)
        {
            var __ret = __Internal.GlfwGetProcAddress(procname);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWglproc)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Com.GitHub.ZachDeibert.GraphicsCore.Platforms.Desktop.GLFWglproc));
        }

        /// <summary>Returns whether the Vulkan loader has been found.</summary>
        /// <returns>
        /// <para>`GLFW_TRUE` if Vulkan is available, or `GLFW_FALSE` otherwise.</para>
        /// <para>Possible errors include</para>
        /// <para>This function may be called from any thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns whether the Vulkan loader has been found.  This check</para>
        /// <para>is performed by</para>
        /// <para>The availability of a Vulkan loader does not by itself guarantee that window</para>
        /// <para>surface creation or even device creation is possible.  Call</para>
        /// <para>glfwGetRequiredInstanceExtensions to check whether the extensions necessary</para>
        /// <para>for Vulkan surface creation are available and</para>
        /// <para>glfwGetPhysicalDevicePresentationSupport to check whether a queue family of</para>
        /// <para>a physical device supports image presentation.</para>
        /// <para>Added in version 3.2.</para>
        /// </remarks>
        public static int GlfwVulkanSupported()
        {
            var __ret = __Internal.GlfwVulkanSupported();
            return __ret;
        }

        /// <summary>Returns the Vulkan instance extensions required by GLFW.</summary>
        /// <param name="count">
        /// <para>Where to store the number of extensions in the returned</para>
        /// <para>array.  This is set to zero if an error occurred.</para>
        /// </param>
        /// <returns>
        /// <para>An array of ASCII encoded extension names, or `NULL` if an</para>
        /// <para>[error](</para>
        /// <para>Possible errors include</para>
        /// <para>GLFW_API_UNAVAILABLE.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns an array of names of Vulkan instance extensions required</para>
        /// <para>by GLFW for creating Vulkan surfaces for GLFW windows.  If successful, the</para>
        /// <para>list will always contains `VK_KHR_surface`, so if you don't require any</para>
        /// <para>additional extensions you can pass this list directly to the</para>
        /// <para>`VkInstanceCreateInfo` struct.</para>
        /// <para>If Vulkan is not available on the machine, this function returns `NULL` and</para>
        /// <para>generates a</para>
        /// <para>to check whether Vulkan is available.</para>
        /// <para>If Vulkan is available but no set of extensions allowing window surface</para>
        /// <para>creation was found, this function returns `NULL`.  You may still use Vulkan</para>
        /// <para>for off-screen rendering and compute work.</para>
        /// <para>Additional extensions may be required by future versions of GLFW.</para>
        /// <para>You should check if any extensions you wish to enable are already in the</para>
        /// <para>returned array, as it is an error to specify an extension more than once in</para>
        /// <para>the `VkInstanceCreateInfo` struct.</para>
        /// <para>The returned array is allocated and freed by GLFW.  You</para>
        /// <para>should not free it yourself.  It is guaranteed to be valid only until the</para>
        /// <para>library is terminated.</para>
        /// <para>This function may be called from any thread.</para>
        /// <para>glfwCreateWindowSurface</para>
        /// <para>Added in version 3.2.</para>
        /// </remarks>
        public static sbyte** GlfwGetRequiredInstanceExtensions(ref uint count)
        {
            fixed (uint* __refParamPtr0 = &count)
            {
                var __arg0 = __refParamPtr0;
                var __ret = __Internal.GlfwGetRequiredInstanceExtensions(__arg0);
                return __ret;
            }
        }
    }
}
